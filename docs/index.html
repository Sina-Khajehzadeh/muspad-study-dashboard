<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MUSPAD Dynamic Dashboard</title>

  <!-- Bootstrap CSS + Icons (no SRI to avoid integrity mismatches) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">

  <!-- Plotly.js for charts + PapaParse for CSV -->
  <script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Tiny inline favicon to avoid 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%23007bff'/%3E%3Ctext x='50%25' y='54%25' font-size='42' text-anchor='middle' fill='white'%3EM%3C/text%3E%3C/svg%3E"/>

  <style>
    :root {
      --sidebar-w: 50px;
      --card-min: 400px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Helvetica, sans-serif; overflow: hidden; }
    #app { display: flex; height: 100vh; overflow: hidden; }

    /* Sidebar */
    #sidebar {
      width: var(--sidebar-w);
      background: #f5f5f5;
      border-right: 1px solid #e1e1e1;
      display: flex; flex-direction: column; align-items: center; gap: .75rem;
      padding: .75rem .25rem;
    }
    #sidebar button {
      width: 36px; height: 36px; border: 0; background: transparent; border-radius: 8px;
      display: grid; place-items: center; font-size: 1.25rem; color: #333; cursor: pointer;
    }
    #sidebar button:hover { background: #e9ecef; color: #0d6efd; }

    /* Main column */
    #main { flex: 1; display: flex; flex-direction: column; min-width: 0; overflow: hidden; }

    /* Header */
    #header {
      display: flex; align-items: center; gap: 1rem;
      padding: .5rem 1rem; border-bottom: 1px solid #e1e1e1; background: #fff;
    }
    #title { margin: 0; font-size: 1.5rem; font-weight: 600; }
    #loadedBadge { font-size: .9rem; color: #6c757d; }
    .header-spacer { flex: 1; }
    .date-range { display: flex; gap: .5rem; }

    /* Panels */
    .panel { display: none; background: #f8f9fa; border-bottom: 1px solid #e1e1e1; padding: .75rem 1rem; overflow: auto; }
    .panel.active { display: block; }
    .panel h5 { margin-bottom: .75rem; }

    .filter-row { display: grid; grid-template-columns: 1fr auto auto; gap: .5rem; align-items: start; }
    .filter-actions .btn { white-space: nowrap; }

    /* Grid */
    #grid {
      flex: 1; overflow: auto; padding: 1rem;
      display: flex; flex-wrap: wrap; gap: 1rem;
    }
    .card-chart {
      width: calc(50% - .5rem);
      min-width: var(--card-min);
      background: #fff; border: 1px solid #e1e1e1; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,.06);
    }
    .card-chart .card-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: .5rem .75rem; border-bottom: 1px solid #eee;
    }
    .card-chart .card-header h6 { margin: 0; font-size: 1rem; font-weight: 600; }
    .card-chart .remove { border: 0; background: transparent; color: #6c757d; font-size: 1.1rem; }
    .card-chart .remove:hover { color: #dc3545; }
    .card-chart .plot { height: 320px; padding: .5rem; }

    @media (max-width: 800px) {
      .card-chart { width: 100%; min-width: 100%; }
    }

    /* Modal */
    #modal {
      position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.45); z-index: 1000;
      padding: 1rem;
    }
    #modal .sheet {
      width: min(600px, 100%); background: #fff; border-radius: 10px; padding: 1rem 1rem 1.25rem;
      box-shadow: 0 8px 24px rgba(0,0,0,.2);
    }
    #modal .grid { display: grid; gap: .75rem; }
    #modal .actions { display: flex; justify-content: flex-end; gap: .5rem; margin-top: .75rem; }

/* ===== Inspector panel styles START ===== */

/* Data panel two-column layout */
#dataLayout {
  display: grid;
  grid-template-columns: 1fr 320px;
  gap: 1rem;
  min-height: 300px;
}

/* Right inspector panel */
#inspector {
  background: #fff;
  border: 1px solid #e1e1e1;
  border-radius: 8px;
  padding: .75rem;
  box-shadow: 0 2px 4px rgba(0,0,0,.06);
  display: flex;
  flex-direction: column;
  gap: .75rem;
  max-height: 60vh;
  overflow: hidden;
}

/* Blocks inside inspector */
.inspector-block {
  border: 1px solid #f0f0f0;
  border-radius: 6px;
  padding: .5rem .6rem;
  background: #fafafa;
}
.inspector-title {
  margin: 0 0 .5rem 0;
  font-size: .95rem;
  font-weight: 600;
}

/* KPI grid */
.inspector-kpis {
  display: grid;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap: .5rem;
}
.kpi { background:#fff; border:1px solid #eee; border-radius:6px; padding:.4rem .5rem; }
.kpi-wide { grid-column: 1 / -1; }
.kpi-label { font-size:.75rem; color:#6c757d; }
.kpi-value { font-weight:600; }

/* Column list (scrollable) */
.inspector-list {
  display: grid;
  grid-template-columns: 1fr;
  gap: .35rem;
  max-height: 22vh;
  overflow: auto;
}
.inspector-list button {
  width: 100%;
  text-align: left;
  padding: .35rem .5rem;
  border: 1px solid #e1e1e1;
  background: #fff;
  border-radius: 6px;
  font-size: .9rem;
  cursor: pointer;
}
.inspector-list button:hover { background:#f5f8ff; border-color:#cfe2ff; }
.inspector-list button.active { background:#e7f1ff; border-color:#9ec5fe; }

/* Field stats area (scrollable if long) */
#fieldStats {
  max-height: auto;
  overflow: auto;
  background:#fff;
  border:1px solid #eee;
  border-radius:6px;
  padding:.5rem;
}

/* Responsive: stack on small screens */
@media (max-width: 900px) {
  #dataLayout {
    grid-template-columns: 1fr;
  }
  #inspector {
    max-height: none;
  }
}
/* ===== Inspector panel styles END ===== */
</style>
</head>
<body>
  <div id="app">
    <!-- Sidebar -->
    <aside id="sidebar" aria-label="Toolbar">
      <button id="btnFilters" title="Filters" aria-label="Filters"><i class="bi bi-funnel-fill"></i></button>
      <button id="btnData" title="Data table" aria-label="Data"><i class="bi bi-table"></i></button>
      <button id="btnSettings" title="Settings" aria-label="Settings"><i class="bi bi-gear-fill"></i></button>
      <button id="btnAdd" title="Add chart" aria-label="Add chart"><i class="bi bi-plus-lg"></i></button>
    </aside>

    <!-- Main -->
    <main id="main">
      <header id="header">
        <h1 id="title">MUSPAD Dynamic Dashboard</h1>
        <span id="loadedBadge" aria-live="polite"></span>
        <div class="header-spacer"></div>
        <div class="date-range">
          <input type="date" id="startDate" aria-label="Start date">
          <input type="date" id="endDate" aria-label="End date">
        </div>
      
        <!-- Add this button -->
        <button id="btnDownloadFiltered" type="button" class="btn btn-sm btn-outline-primary">
          Download filtered CSV
        </button>
      </header>


      <!-- Filters -->
      <section id="panelFilters" class="panel" aria-label="Filters">
        <h5 class="mb-3">Filters</h5>
        <!-- Dynamic filter container: populated based on dataset columns -->
        <div id="filter-container"></div>
      </section>

      <!-- Data table -->
      <section id="panelData" class="panel" aria-label="Data preview">
        <h5 class="mb-2">Data Preview</h5>
      
        <!-- Two-column layout: table left, inspector right -->
        <div id="dataLayout">
          <!-- LEFT: data table -->
          <div class="table-responsive" id="tableWrap"></div>
      
          <!-- RIGHT: inspector -->
          <aside id="inspector" aria-label="Variable Inspector & Dataset Summary">
            <!-- Top: dataset summary -->
            <div id="inspectorSummary" class="inspector-block">
              <h6 class="inspector-title">Dataset summary</h6>
              <div class="inspector-kpis">
                <div class="kpi"><div class="kpi-label">Total rows</div><div class="kpi-value" id="sumTotalRows">â€”</div></div>
                <div class="kpi"><div class="kpi-label">Total cols</div><div class="kpi-value" id="sumTotalCols">â€”</div></div>
                <div class="kpi"><div class="kpi-label">Filtered rows</div><div class="kpi-value" id="sumFilteredRows">â€”</div></div>
                <div class="kpi kpi-wide"><div class="kpi-label">Date range</div><div class="kpi-value" id="sumDateRange">â€”</div></div>
              </div>
            </div>
      
            <!-- Columns list -->
            <div id="inspectorCols" class="inspector-block">
              <h6 class="inspector-title">Columns</h6>
              <div id="inspectorList" class="inspector-list">
                <!-- populated by JS: one <button> per column -->
              </div>
            </div>
      
            <!-- Field details -->
            <div id="inspectorDetails" class="inspector-block">
              <h6 class="inspector-title"><span id="fieldName">Select a column</span></h6>
              <div id="fieldStats">Choose a column from the list to see statistics.</div>
            </div>
          </aside>
        </div>
      </section>


      <!-- Settings -->
      <section id="panelSettings" class="panel" aria-label="Settings">
        <h5>Settings</h5>
        <p class="text-muted mb-0">Add theme/layout options here as needed.</p>
      </section>

      <!-- Chart grid -->
      <section id="grid" aria-label="Charts"></section>
    </main>
  </div>

  <!-- Chart Builder Modal -->
  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="sheet">
      <h5 id="modalTitle" class="mb-3">Create chart</h5>
  
      <!-- BASIC FIELDS (always shown) -->
      <div class="grid">
        <div>
          <label class="form-label">Chart type</label>
          <select id="fldType" class="form-select">
            <option value="bar">Column / Bar</option>
            <option value="barline">Bar + Line (combo)</option>
            <option value="pie">Pie Chart</option>
            <option value="timeseries">Time Series</option>
            <option value="line">Line Plot</option>
            <option value="heatmap">Heatmap</option>
            <option value="funnel">Funnel Chart</option>
            <option value="scatter">Scatter Plot</option>
            <option value="bubble">Bubble Chart</option>
            <option value="box">Box Plot</option>
            <option value="pivot">Pivot Table</option>
            <option value="datatable">Data Table</option>
          </select>
        </div>
  
        <div>
          <label class="form-label">X / Row / Category</label>
          <select id="fldX" class="form-select"></select>
        </div>
  
        <div data-role="needsNumeric">
          <label class="form-label">Y / Value (numeric)</label>
          <select id="fldY" class="form-select"></select>
        </div>
  
        <div data-role="needsSecondCat">
          <label class="form-label">Column (2nd category) â€” for Heatmap / Pivot</label>
          <select id="fldYCat" class="form-select"></select>
        </div>
  
        <div data-role="needsColor">
          <label class="form-label">Color / Group (optional)</label>
          <select id="fldColor" class="form-select"></select>
        </div>
  
        <div data-role="needsAgg">
          <label class="form-label">Aggregation</label>
          <select id="fldAgg" class="form-select">
            <option value="count">Count</option>
            <option value="sum">Sum</option>
            <option value="mean">Mean</option>
          </select>
        </div>
  
        <!-- Combo / special fields -->
        <div data-role="needsY2">
          <label class="form-label">Y2 (numeric) â€” for Bar+Line</label>
          <select id="fldY2" class="form-select"></select>
        </div>
  
        <div data-role="needsSize">
          <label class="form-label">Size (numeric) â€” for Bubble</label>
          <select id="fldSize" class="form-select"></select>
        </div>
  
        <div data-role="comboToggles">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="chkDualAxis">
            <label class="form-check-label" for="chkDualAxis">Use dual Y-axis (Bar+Line)</label>
          </div>
          <div class="form-check" data-role="histToggle">
            <input class="form-check-input" type="checkbox" id="chkHistOverlay">
            <label class="form-check-label" for="chkHistOverlay">Add histogram overlay (Line / Box)</label>
          </div>
        </div>
      </div>
  
      <div class="actions">
        <button id="btnCancel" class="btn btn-outline-secondary">Cancel</button>
        <button id="btnCreate" class="btn btn-primary">Create</button>
      </div>
    </div>
  </div>
  <script>

      // ----------------------------
      // Global state
      // ----------------------------
      let rawData = [];
      let filtered = [];
      let columns = [];
      let charts = [];
      let dateCol = null;
      let ageCol  = null;
      let empCol  = null;
      let numericCols = [];
      let categoricalCols = [];
      let inspectorSelectedField = null; // Track which column is currently selected in the inspector
    
      // ----------------------------
      // Boot
      // ----------------------------
      document.addEventListener('DOMContentLoaded', () => {
        wireUI();
        loadCSV();
      });
    
      function wireUI() {
        // Sidebar toggles
        id('btnFilters').addEventListener('click', () => toggle('panelFilters'));
        id('btnData').addEventListener('click', () => toggle('panelData'));
        id('btnSettings').addEventListener('click', () => toggle('panelSettings'));
        id('btnAdd').addEventListener('click', () => {
          updateBuilderVisibility();   // ensure correct fields show when opening
          openModal();
        });
    
        // Date change
        id('startDate').addEventListener('change', applyFilters);
        id('endDate').addEventListener('change', applyFilters);


    
        // Modal controls
        id('btnCancel').addEventListener('click', closeModal);
        id('btnCreate').addEventListener('click', () => {
          // build config with all optional fields
          const cfg = {
            type:    id('fldType').value,
            x:       id('fldX').value || null,
            y:       id('fldY').value || null,
            y2:      id('fldY2').value || null,
            yCat:    id('fldYCat').value || null,
            color:   id('fldColor').value || null,
            size:    id('fldSize').value || null,
            agg:     id('fldAgg').value || 'count',
            dualAxis:    id('chkDualAxis').checked,
            histOverlay:id('chkHistOverlay').checked
          };
          addChart(cfg);    // actually create the chart
          closeModal();
        });
    
        // Close modal by clicking on the backdrop
        id('modal').addEventListener('click', (e) => {
          if (e.target === id('modal')) closeModal();
        });
    
        // Update builder visibility when chart type changes
        if (id('fldType')) {
          id('fldType').addEventListener('change', updateBuilderVisibility);
          updateBuilderVisibility();
        }
  
      // Download filtered CSV
      id('btnDownloadFiltered').addEventListener('click', () => {
        if (!filtered.length) {
          alert('No rows in the current filter.');
          return;
        }
      downloadCSV('filtered_data.csv', columns, filtered.map(r => columns.map(c => r[c])));
    }); 
      }

    
      // ----------------------------
      // Builder field visibility
      // ----------------------------
      function updateBuilderVisibility() {
        const type = id('fldType').value;
        const show = (selector, on) => {
          document.querySelectorAll(selector).forEach(el => {
            el.style.display = on ? '' : 'none';
          });
        };
        // Which fields should be visible per chart type
        show('[data-role="needsNumeric"]', !['pie','heatmap','pivot','datatable','funnel'].includes(type));
        show('[data-role="needsAgg"]', !['scatter','bubble','box','datatable','pivot'].includes(type));
        show('[data-role="needsColor"]', ['bar','line','scatter','bubble','box','barline'].includes(type));
        show('[data-role="needsSecondCat"]', ['heatmap','pivot'].includes(type));
        show('[data-role="needsY2"]', type === 'barline');
        show('[data-role="needsSize"]', type === 'bubble');
        show('[data-role="comboToggles"]', ['barline','line','box'].includes(type));
        show('[data-role="histToggle"]', ['line','box'].includes(type));
      }


    // ----------------------------
    // Data loading (with fallbacks)
    // ----------------------------
    function loadCSV() {
      const urls = [
        // 1) Relative to GitHub Pages root (docs/ is the site root)
        'data/df3_full_for_pivot.csv',
        // 2) Explicit Pages URL
        'https://sina-khajehzadeh.github.io/muspad-study-dashboard/data/df3_full_for_pivot.csv',
        // 3) Raw GitHub
        'https://raw.githubusercontent.com/Sina-Khajehzadeh/muspad-study-dashboard/main/docs/data/df3_full_for_pivot.csv',
        // 4) jsDelivr (may cache; keep as last resort)
        'https://cdn.jsdelivr.net/gh/Sina-Khajehzadeh/muspad-study-dashboard/docs/data/df3_full_for_pivot.csv'
      ];

      let idx = 0;
      const tryNext = () => {
        if (idx >= urls.length) {
          alert('Failed to load CSV from all sources.');
          return;
        }
        const url = urls[idx++];
        console.log('Loading data from', url);
        Papa.parse(url, {
          download: true,
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          worker: false,
          delimiter: "", // auto-detect
          transformHeader: (h) => (h || '').replace(/^\uFEFF/, '').trim(),
          complete: (res) => {
            if (!res || !Array.isArray(res.data) || res.data.length === 0) {
              console.warn('Parsed but empty. Trying next sourceâ€¦');
              tryNext();
              return;
            }
            rawData = res.data;
            columns = (res.meta && res.meta.fields && res.meta.fields.length)
              ? res.meta.fields
              : Object.keys(rawData[0] || {});
            id('loadedBadge').textContent = `Loaded ${rawData.length.toLocaleString()} rows â€¢ ${columns.length} columns`;

            detectColumns();
            populateFilters();
            populateBuilderSelects();
            
            // Inspector: build list + summary once we know columns
            rebuildInspectorColumnList();
            updateInspectorSummary();
            
            // Start with data visible & some starter charts
            show('panelData', true);
            applyFilters();
            autoStarterCharts();

          },
          error: (err) => {
            console.error('Papa error:', err);
            tryNext();
          }
        });
      };
      tryNext();
    }

    // ----------------------------
    // Column detection (date/age/employment)
    // ----------------------------
    function detectColumns() {
      // 1) Date column: prefer names that hint date/time and pass parse checks
      const nameHint = /(date|time|_dt|_time|timestamp)/i;
      const candidates = columns.filter(c => nameHint.test(c));
      const ranked = (candidates.length ? candidates : columns).map(c => {
        const score = scoreDateColumn(c);
        return { col: c, ...score };
      }).filter(s => s.valid);

      ranked.sort((a,b) => b.confidence - a.confidence);
      dateCol = ranked.length ? ranked[0].col : null;

      // 2) Age group columns (list includes dataset-specific names)
      const ageCandidates = [
        'age_group','ageGroup','Age_Group',
        'age_group_22_1','age_group_22_2','age_group_23_1','age_group_23_2'
      ];
      ageCol = ageCandidates.find(c => columns.includes(c)) || null;

      // 3) Employment type columns (extended list, includes "langfragen" variant)
      const empCandidates = [
        'employment_type','employmentType','Employment_Type',
        'X20_21_kurzfragen_employment_type_clean','employment_type_clean',
        'X20_21_langfragen_employment_type_clean'
      ];
      empCol = empCandidates.find(c => columns.includes(c)) || null;

      // 4) Determine numeric and categorical columns for filtering and charting
      // numericCols: columns where the majority of sampled values are numbers
      // categoricalCols: columns with distinct values between 2 and 50 and not mostly numeric
      numericCols = columns.filter(c => looksNumericColumn(c));
      categoricalCols = columns.filter(c => looksCategoricalColumn(c));
    }

    // Heuristic to validate date-like column
    function scoreDateColumn(col) {
      const vals = sampleValues(col, 300);
      let parsed = 0, withinRange = 0;
      for (const v of vals) {
        const d = new Date(v);
        if (!isNaN(d)) {
          parsed++;
        const y = d.getUTCFullYear();
        // Accept dates only inside a reasonable window (2000â€“2050).
        // Otherwise things like 1970/2030 (Unix epoch defaults or parsing artefacts) will pollute our detection.
        if (y >= 2000 && y <= 2050) withinRange++;
        }
      }
      const rate = vals.length ? parsed / vals.length : 0;
      // Only count years that fall within our acceptable range (2000â€‘2050).
      // This helps avoid spurious dates like 1970/2030 that appear when parsing invalid values.
      const rangeRate = vals.length ? withinRange / vals.length : 0;
      const valid = rate >= 0.7 && rangeRate >= 0.7;
      const confidence = (rate + rangeRate) / 2 + (/(date|time|timestamp)/i.test(col) ? 0.1 : 0);
      return { valid, confidence };
    }

    function sampleValues(col, n=200) {
      const arr = [];
      const step = Math.max(1, Math.floor(rawData.length / n));
      for (let i=0; i<rawData.length; i+=step) {
        const v = rawData[i]?.[col];
        if (v !== undefined && v !== null && v !== '') arr.push(v);
        if (arr.length >= n) break;
      }
      return arr;
    }

    // ----------------------------
    // Populate filters & builder
    // ----------------------------
    function populateFilters() {
      const container = id('filter-container');
      container.innerHTML = '';

      // Create one filter select for each categorical column with a reasonable number of unique values
      categoricalCols.forEach(col => {
        const values = uniqueNonEmpty(rawData.map(r => r[col]));
        // Skip columns with too many distinct values (e.g. >50) to avoid huge selects
        if (values.length > 50) return;
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-3';
        const label = document.createElement('label');
        label.className = 'form-label';
        label.textContent = col;
        wrapper.appendChild(label);
        const row = document.createElement('div');
        row.className = 'filter-row';
        const select = document.createElement('select');
        select.className = 'form-select';
        select.multiple = true;
        select.size = Math.min(values.length, 6);
        select.dataset.col = col;
        // Populate options
        values.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = v;
          opt.selected = true;
          select.appendChild(opt);
        });
        // Actions: select all / clear
        const actions = document.createElement('div');
        actions.className = 'filter-actions';
        const btnSel = document.createElement('button');
        btnSel.className = 'btn btn-outline-secondary btn-sm';
        btnSel.textContent = 'Select all';
        btnSel.addEventListener('click', () => {
          for (const o of select.options) o.selected = true;
          select.dispatchEvent(new Event('change'));
        });
        const btnClr = document.createElement('button');
        btnClr.className = 'btn btn-outline-secondary btn-sm';
        btnClr.textContent = 'Clear';
        btnClr.addEventListener('click', () => {
          for (const o of select.options) o.selected = false;
          select.dispatchEvent(new Event('change'));
        });
        actions.appendChild(btnSel);
        actions.appendChild(btnClr);
        row.appendChild(select);
        row.appendChild(actions);
        wrapper.appendChild(row);
        container.appendChild(wrapper);
        // event to apply filters
        select.addEventListener('change', applyFilters);
      });

      // Prepare date inputs 
    if (dateCol) {
      // Build a sorted list of valid dates while ignoring outâ€‘ofâ€‘range values.
      const dates = rawData
      .map(r => parseValidDate(r[dateCol]))
      .filter(Boolean)
      .sort((a,b) => a - b);
  
    if (dates.length) {
      const minISO = toISO(dates[0]);
      const maxISO = toISO(dates[dates.length-1]);
  
      id('startDate').min = minISO;
      id('startDate').max = maxISO;
      id('endDate').min   = minISO;
      id('endDate').max   = maxISO;
      id('startDate').dataset.col = dateCol;
      id('endDate').dataset.col   = dateCol;
  
      // ðŸ‘‡ NEW: prefill the inputs to the data range
      id('startDate').value = minISO;   // earliest date in data
      id('endDate').value   = maxISO;   // latest date in data
    }
  }
    }

    function populateBuilderSelects() {
      const xSel = id('fldX'), ySel = id('fldY'), cSel = id('fldColor');
      const y2Sel = id('fldY2'), yCatSel = id('fldYCat'), sizeSel = id('fldSize');
    
      [xSel, ySel, cSel, y2Sel, yCatSel, sizeSel].forEach(s => s.innerHTML = '');
    
      // Prefer to list categorical columns first for X / YCat, and numeric first for Y/Y2/Size.
      const cats = categoricalCols.length ? categoricalCols : columns;
      const nums = numericCols.length ? numericCols : columns;
    
      cats.forEach(c => { appendOption(xSel, c); appendOption(yCatSel, c); appendOption(cSel, c); });
      nums.forEach(c => { appendOption(ySel, c); appendOption(y2Sel, c); appendOption(sizeSel, c); });
    
      updateBuilderVisibility();
    }


    // ----------------------------
    // Filtering + table
    // ----------------------------
    function applyFilters() {
      const s = id('startDate').value ? new Date(id('startDate').value) : null;
      const e = id('endDate').value ? new Date(id('endDate').value) : null;

      // Build a map of selected values for each categorical filter
      const filterContainer = id('filter-container');
      const filterSelects = filterContainer.querySelectorAll('select[data-col]');
      const filterMap = {};
      filterSelects.forEach(sel => {
        const col = sel.dataset.col;
        const selected = Array.from(sel.selectedOptions).map(o => String(o.value));
        filterMap[col] = selected;
      });

      filtered = rawData.filter(r => {
        // date filter
        if (dateCol && (s || e)) {
          // Parse the row's date using the safe helper. Invalid or outâ€‘ofâ€‘range values
          // are treated as missing and filtered out.
          const d = parseValidDate(r[dateCol]);
          if (!d) return false;
          if (s && d < s) return false;
          if (e && d > e) return false;
        }
        // categorical filters
        for (const col in filterMap) {
          const selected = filterMap[col];
          if (selected && selected.length) {
            if (!selected.includes(String(r[col]))) return false;
          }
        }
        return true;
      });

      updateTable();
      charts.forEach(drawChart);
     
  if (dateCol) {
    // Determine the range of valid dates among the filtered rows. Invalid or
    // outâ€‘ofâ€‘range values are ignored via parseValidDate().
    const ds = filtered
      .map(r => parseValidDate(r[dateCol]))
      .filter(Boolean)
      .sort((a,b) => a - b);
    if (ds.length) {
      id('startDate').value = toISO(ds[0]);
      id('endDate').value   = toISO(ds[ds.length - 1]);
    }
  }
 
      // Inspector: recompute summary + current field stats (on filtered)
      updateInspectorSummary();
      if (inspectorSelectedField) {
        showFieldStats(inspectorSelectedField);
      }    
    }

    function updateTable() {
      const wrap = id('tableWrap');
      wrap.innerHTML = '';
      if (!filtered.length) {
        wrap.innerHTML = '<div class="text-muted">No data to display</div>';
        return;
      }
      const table = document.createElement('table');
      table.className = 'table table-sm table-striped';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      for (const c of columns) {
        const th = document.createElement('th'); th.textContent = c; trh.appendChild(th);
      }
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      const rows = filtered.slice(0, 100);
      for (const r of rows) {
        const tr = document.createElement('tr');
        for (const c of columns) {
          const td = document.createElement('td');
          const v = r[c]; td.textContent = (v === undefined || v === null) ? '' : v;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(thead); table.appendChild(tbody);
      wrap.appendChild(table);
    }

    // ----------------------------
    // Starter charts (auto-create)
    // ----------------------------
    function autoStarterCharts() {
      // derive candidates
      // Use detected numericCols/categoricalCols globals
      const numCols = numericCols;
      const catCols = categoricalCols;

      // choose candidate numeric for income or metric
      const income = ['X20_21_langfragen_income','income'].find(c => columns.includes(c)) || (numCols.length ? numCols[0] : null);
      // choose candidate age-like column
      const age = catCols.find(c => /age/i.test(c)) || (catCols.length ? catCols[0] : null);
      // choose candidate employment-like column
      const emp = catCols.find(c => /employ|job|work/i.test(c)) || (catCols.length > 1 ? catCols[1] : null);

      // 1) Pie of employment counts (if available)
      if (emp) addChart({ type: 'pie', x: emp, y: income || emp, agg: 'count' });

      // 2) Bar: mean income by age group (or first numeric)
      if (age && income) addChart({ type: 'bar', x: age, y: income, agg: 'mean' });

      // 3) Line over time (if we have a date + numeric)
      if (dateCol && income) addChart({ type: 'line', x: dateCol, y: income, agg: 'mean' });
    }

    function looksNumericColumn(col) {
      const vals = sampleValues(col, 200);
      if (!vals.length) return false;
      let nums = 0;
      for (const v of vals) if (typeof v === 'number' && !Number.isNaN(v)) nums++;
      // Consider numeric if at least 70% are numbers
      return nums / vals.length >= 0.7;
    }

    function looksCategoricalColumn(col) {
      const vals = sampleValues(col, 400);
      const uniq = new Set(vals.filter(v => v !== '' && v !== null && v !== undefined).map(String));
      // categorical if distinct values between 2 and 20 and not mostly numbers
      const mostlyNums = looksNumericColumn(col);
      return !mostlyNums && uniq.size >= 2 && uniq.size <= 20;
    }

    function makePivotMatrix(rows, rowKey, colKey, valKey, aggName='count') {
      const rset = new Set(), cset = new Set();
      const map = new Map(); // key = rÂ¦c -> array of rows
      rows.forEach(r => {
        const rk = String(r[rowKey]);
        const ck = String(r[colKey]);
        rset.add(rk); cset.add(ck);
        const key = rk + 'Â¦' + ck;
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(r);
      });
      const rArr = Array.from(rset), cArr = Array.from(cset);
      const aggCell = (arr) => {
        if (aggName === 'count') return arr.length;
        const vs = arr.map(x => +x[valKey]).filter(v => !Number.isNaN(v));
        if (!vs.length) return 0;
        if (aggName === 'sum')  return vs.reduce((a,b)=>a+b,0);
        return vs.reduce((a,b)=>a+b,0)/vs.length;
      };
      const z = rArr.map(rk => cArr.map(ck => aggCell(map.get(rk+'Â¦'+ck) || [])));
      // Build HTML table too (for pivot card)
      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      trh.appendChild(Object.assign(document.createElement('th'), {textContent: rowKey + ' \\ ' + colKey}));
      cArr.forEach(c => trh.appendChild(Object.assign(document.createElement('th'), {textContent: c})));
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      rArr.forEach((rk, i) => {
        const tr = document.createElement('tr');
        tr.appendChild(Object.assign(document.createElement('td'), {textContent: rk}));
        z[i].forEach(v => tr.appendChild(Object.assign(document.createElement('td'), {textContent: v})));
        tbody.appendChild(tr);
      });
      table.appendChild(thead); table.appendChild(tbody);
      return { rows: rArr, cols: cArr, z, html: table.outerHTML };
    }
    
    
    // ----------------------------
    // Charting
    // ----------------------------
    function addChart(cfg) {
      charts.push(cfg);
      const card = document.createElement('div');
      card.className = 'card-chart';
      card.innerHTML = `
        <div class="card-header">
          <h6>${titleFor(cfg)}</h6>
          <button class="remove" title="Remove"><i class="bi bi-x-lg"></i></button>
        </div>
        <div class="plot"></div>
      `;
      id('grid').appendChild(card);
      cfg._el = card.querySelector('.plot');
      card.querySelector('.remove').addEventListener('click', () => {
        charts = charts.filter(c => c !== cfg);
        card.remove();
      });
      drawChart(cfg);
    }

    function titleFor(cfg) {
      const t = cfg.type[0].toUpperCase() + cfg.type.slice(1);
      const parts = [`${t}`];
      if (cfg.x) parts.push(`X: ${cfg.x}`);
      if (cfg.y && cfg.agg) parts.push(`Y: ${cfg.agg}(${cfg.y})`);
      if (cfg.color) parts.push(`Color: ${cfg.color}`);
      return parts.join(' Â· ');
    }

    function drawChart(cfg) {
      const el = cfg._el;
      if (cfg.type === 'datatable') {
        // render a data table card of the current filtered rows
        el.innerHTML = '';
        const wrap = document.createElement('div');
        wrap.className = 'table-responsive';
        el.appendChild(wrap);
        const table = document.createElement('table');
        table.className = 'table table-sm table-striped';
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        columns.forEach(c => { const th = document.createElement('th'); th.textContent = c; trh.appendChild(th); });
        thead.appendChild(trh);
        const tbody = document.createElement('tbody');
        (filtered.slice(0,200)).forEach(r => {
          const tr = document.createElement('tr');
          columns.forEach(c => {
            const td = document.createElement('td'); td.textContent = (r[c] ?? ''); tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(thead); table.appendChild(tbody);
        wrap.appendChild(table);
        return;
      }
    
      if (cfg.type === 'pivot') {
        // simple pivot to HTML table: rows = cfg.x, cols = cfg.yCat, values = agg(cfg.y)
        const matrix = makePivotMatrix(filtered, cfg.x, cfg.yCat, cfg.y, cfg.agg);
        el.innerHTML = matrix.html;
        return;
      }
    
      if (!filtered.length) { el.innerHTML = '<div class="text-muted p-2">No data</div>'; return; }
    
      const groupBy = (rows, keys) => {
        const map = new Map();
        for (const r of rows) {
          const key = keys.map(k => String(r[k])).join('Â¦');
          if (!map.has(key)) map.set(key, []);
          map.get(key).push(r);
        }
        return { map, keys };
      };
      const agg = (rows) => {
        if (cfg.agg === 'count') return rows.length;
        const vals = rows.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
        if (!vals.length) return 0;
        if (cfg.agg === 'sum')  return vals.reduce((a,b)=>a+b,0);
        return vals.reduce((a,b)=>a+b,0) / vals.length; // mean
      };
    
      let fig = { data: [], layout: { margin: {l:50,r:20,b:50,t:40}, title: titleFor(cfg) } };
    
      // ---------- BASIC TYPES ----------
      if (cfg.type === 'bar' || cfg.type === 'pie') {
        const by = cfg.color ? [cfg.x, cfg.color] : [cfg.x];
        const g = groupBy(filtered, by);
        const xs = new Set(), colors = new Set();
        for (const k of g.map.keys()) {
          const parts = k.split('Â¦'); xs.add(parts[0]); if (cfg.color) colors.add(parts[1]);
        }
        const xArr = Array.from(xs), colorArr = cfg.color ? Array.from(colors) : [null];
    
        if (cfg.type === 'bar') {
          for (const cval of colorArr) {
            const y = xArr.map(xv => {
              const key = cfg.color ? [xv, cval].join('Â¦') : String(xv);
              return agg(g.map.get(key) || []);
            });
            fig.data.push({ x: xArr, y, type: 'bar', name: cval ?? 'value' });
          }
          fig.layout.barmode = 'group';
          fig.layout.xaxis = { title: cfg.x };
          if (cfg.y) fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };
        } else {
          const values = xArr.map(xv => {
            const rows = Array.from(g.map.entries()).filter(([k]) => k.split('Â¦')[0] == xv).flatMap(([,rows]) => rows);
            return agg(rows);
          });
          fig.data.push({ labels: xArr, values, type: 'pie', hole: .35 });
        }
      }
    
      else if (cfg.type === 'line' || cfg.type === 'timeseries') {
        // timeseries is just line with a date-ish X
        const g = groupBy(filtered, [cfg.x]);
        const xVals = Array.from(g.map.keys()).map(k => k.split('Â¦')[0]);
        const sorted = xVals.slice().sort((a,b) => {
          const da = new Date(a), db = new Date(b);
          if (!isNaN(da) && !isNaN(db)) return da - db;
          const na = +a, nb = +b;
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
          return String(a).localeCompare(String(b));
        });
        const yVals = sorted.map(xv => agg(g.map.get(String(xv)) || g.map.get(xv) || []));
        fig.data.push({ x: sorted, y: yVals, type: 'scatter', mode: 'lines+markers', name: cfg.y });
    
        if (cfg.histOverlay) {
          const vals = filtered.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
          fig.data.push({ x: vals, type: 'histogram', opacity: 0.35, xaxis: 'x2', yaxis: 'y2', name: 'Histogram' });
          fig.layout.grid = { rows: 1, columns: 2, pattern: 'independent' };
          fig.layout.xaxis2 = {};
          fig.layout.yaxis2 = {};
          fig.layout.title += ' Â· + Histogram';
        }
        fig.layout.xaxis = { title: cfg.x };
        if (cfg.y) fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };
      }
    
      else if (cfg.type === 'scatter' || cfg.type === 'bubble') {
        const x = filtered.map(r => r[cfg.x]), y = filtered.map(r => r[cfg.y]);
        const trace = { x, y, mode: 'markers', type: 'scatter', name: cfg.y };
        if (cfg.type === 'bubble' && cfg.size) {
          const s = filtered.map(r => +r[cfg.size]);
          const min = Math.min(...s.filter(v => !Number.isNaN(v))), max = Math.max(...s.filter(v => !Number.isNaN(v)));
          const scaled = s.map(v => Number.isNaN(v) ? 5 : (10 + 30 * ((v - min) / Math.max(1e-9, max - min))));
          trace.marker = { size: scaled, sizemode: 'diameter', opacity: 0.7 };
        }
        if (cfg.color) trace.text = filtered.map(r => r[cfg.color]);
        fig.data.push(trace);
        fig.layout.xaxis = { title: cfg.x };
        fig.layout.yaxis = { title: cfg.y };
      }
    
      else if (cfg.type === 'box') {
        if (!cfg.y) { el.innerHTML = '<div class="text-muted p-2">Please select a numeric Y.</div>'; return; }
        const groups = {};
        filtered.forEach(r => {
          const key = r[cfg.x]; const val = +r[cfg.y];
          if (Number.isNaN(val)) return;
          (groups[key] ||= []).push(val);
        });
        Object.keys(groups).forEach(k => fig.data.push({ y: groups[k], name: String(k), type: 'box' }));
        fig.layout.xaxis = { title: cfg.x }; fig.layout.yaxis = { title: cfg.y };
    
        if (cfg.histOverlay) {
          const vals = filtered.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
          fig.data.push({ x: vals, type: 'histogram', opacity: 0.3, xaxis: 'x2', yaxis: 'y2', name: 'Histogram' });
          fig.layout.grid = { rows: 1, columns: 2, pattern: 'independent' };
          fig.layout.title += ' Â· + Histogram';
        }
      }
    
  else if (cfg.type === 'barline') {
    // bar of agg(y) by X + line of agg(y2) by X (optional dual axis)
    const g = groupBy(filtered, [cfg.x]);
    const xs = Array.from(g.map.keys()).map(k => k.split('Â¦')[0]).sort((a,b)=>String(a).localeCompare(String(b)));
    const aggSeries = (yField) => xs.map(xv => {
      const rows = g.map.get(String(xv)) || g.map.get(xv) || [];
      if (!yField) return 0;
      const vals = rows.map(r => +r[yField]).filter(v => !Number.isNaN(v));
      if (!vals.length) return 0;
      if (cfg.agg === 'sum') return vals.reduce((a,b)=>a+b,0);
      if (cfg.agg === 'mean') return vals.reduce((a,b)=>a+b,0)/vals.length;
      return rows.length;
    });
    const yBar = aggSeries(cfg.y);
    const yLine = aggSeries(cfg.y2);

    fig.data.push({ x: xs, y: yBar, type: 'bar', name: `${cfg.agg}(${cfg.y})` });
    const lineTrace = { x: xs, y: yLine, type: 'scatter', mode: 'lines+markers', name: `${cfg.agg}(${cfg.y2})` };
    if (cfg.dualAxis) { lineTrace.yaxis = 'y2'; fig.layout.yaxis2 = { overlaying: 'y', side: 'right' }; }
    fig.data.push(lineTrace);
    fig.layout.xaxis = { title: cfg.x };
  }

  else if (cfg.type === 'heatmap') {
    // Heatmap of agg(Y) across X (rows) vs YCat (columns)
    const M = makePivotMatrix(filtered, cfg.x, cfg.yCat, cfg.y, cfg.agg);
    fig.data.push({ z: M.z, x: M.cols, y: M.rows, type: 'heatmap', colorscale: 'Viridis' });
    fig.layout.xaxis = { title: cfg.yCat };
    fig.layout.yaxis = { title: cfg.x };
  }

  else if (cfg.type === 'funnel') {
    // Funnel with categories on Y and aggregated numeric width on X
    const g = groupBy(filtered, [cfg.x]);
    const labels = Array.from(g.map.keys()).map(k => k.split('Â¦')[0]);
    const values = labels.map(l => agg(g.map.get(String(l)) || []));
    // sort descending
    const sorted = labels.map((l,i)=>({l, v: values[i]})).sort((a,b)=>b.v-a.v);
    fig.data.push({ type: 'funnel', y: sorted.map(s=>s.l), x: sorted.map(s=>s.v) });
  }

  Plotly.newPlot(el, fig.data, fig.layout, { responsive: true });
}


// ===================== Inspector logic =====================
function updateInspectorSummary() {
  // Totals
  id('sumTotalRows').textContent    = (rawData?.length ?? 0).toLocaleString();
  id('sumTotalCols').textContent    = (columns?.length ?? 0).toLocaleString();
  id('sumFilteredRows').textContent = (filtered?.length ?? 0).toLocaleString();

  // If we don't have a detected date column, show a dash
  if (!dateCol) { id('sumDateRange').textContent = 'â€”'; return; }

  // Use FILTERED rows if any; otherwise fall back to ALL rows
  const rowsForRange = (filtered && filtered.length) ? filtered : rawData;

  // Build sorted list of dates using the safe parser to exclude invalid or
  // outâ€‘ofâ€‘range dates. Without this guard, artefacts like 1970/2030 would
  // incorrectly expand the reported range.
  const dates = rowsForRange
    .map(r => parseValidDate(r[dateCol]))
    .filter(Boolean)
    .sort((a,b) => a - b);

  id('sumDateRange').textContent =
    dates.length ? `${toISO(dates[0])} â†’ ${toISO(dates[dates.length-1])}` : 'â€”';
}

function rebuildInspectorColumnList() {
  const wrap = id('inspectorList');
  wrap.innerHTML = '';
  if (!columns?.length) return;

  // Build buttons
  const frag = document.createDocumentFragment();
  columns.forEach(col => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.textContent = col;
    btn.dataset.col = col;
    frag.appendChild(btn);
  });
  wrap.appendChild(frag);

  // Single click listener for all buttons (works even after rebuilds)
  wrap.onclick = (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    inspectorSelectedField = btn.dataset.col;
    wrap.querySelectorAll('button').forEach(b =>
      b.classList.toggle('active', b === btn)
    );
    showFieldStats(inspectorSelectedField);
  };

  // Preselect first column
  inspectorSelectedField = columns[0];
  const firstBtn = wrap.querySelector('button');
  if (firstBtn) firstBtn.classList.add('active');
  showFieldStats(inspectorSelectedField);
}

function showFieldStats(col) {
  if (!col) return;
  id('fieldName').textContent = col;

  // Use current FILTERED rows
  const vals = (filtered || []).map(r => r[col]);
  const nonNull = vals.filter(v => v !== null && v !== undefined && v !== '');

  // Type detection
  const isNumeric = numericCols.includes(col);
  const isDate = (col === dateCol) || sampleValues(col, 30)
    .some(v => !Number.isNaN(new Date(v)));

  // Helpers
  const fmt = (x, d=3) =>
    (x === undefined || x === null || Number.isNaN(x)) ? 'â€”'
      : Number(x).toLocaleString(undefined, { maximumFractionDigits: d });

  const percent = (num, den) =>
    (den ? (100 * num / den) : 0).toLocaleString(undefined, { maximumFractionDigits: 1 }) + '%';

  const topN = (arr, n=5) => {
    const m = new Map();
    arr.forEach(v => m.set(v, (m.get(v)||0)+1));
    return [...m.entries()].sort((a,b) => b[1]-a[1]).slice(0, n);
  };

  const qtile = (sorted, q) => {
    if (!sorted.length) return NaN;
    const pos = (sorted.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    return (sorted[base+1] !== undefined)
      ? sorted[base] + rest * (sorted[base+1] - sorted[base])
      : sorted[base];
  };

  // Build HTML
  let html = '';

  // 1) Distribution
  const asStr = nonNull.map(v => String(v));
  const top5 = topN(asStr, 5);
  html += `
    <div class="mb-2">
      <h6 class="mb-1">Data Distribution Overview</h6>
      <table class="table table-sm mb-2">
        <thead><tr><th>Value</th><th class="text-end">Share</th></tr></thead>
        <tbody>
          ${top5.map(([k, c]) => `<tr><td>${k}</td><td class="text-end">${percent(c, vals.length)}</td></tr>`).join('')}
        </tbody>
      </table>
    </div>
  `;

  // 2) Quality metrics
  const filled = nonNull.length;
  const uniqueCount = new Set(asStr).size;
  const avgLen = asStr.length ? (asStr.reduce((s,v)=>s+v.length,0)/asStr.length) : 0;
  // For numeric columns the concept of "average string length" isn't meaningful,
  // so display a dash instead of a number. Otherwise show the calculated length.
  const avgLenDisplay = isNumeric ? 'â€”' : fmt(avgLen, 2);
  html += `
    <div class="mb-2">
      <h6 class="mb-1">Data Quality Metrics</h6>
      <table class="table table-sm mb-2">
        <tbody>
          <tr><th class="text-muted">Filled percentage</th><td>${percent(filled, vals.length)}</td></tr>
          <tr><th class="text-muted">Filled values</th><td>${filled.toLocaleString()}</td></tr>
          <tr><th class="text-muted">Avg. Length</th><td>${avgLenDisplay}</td></tr>
          <tr><th class="text-muted">Unique Items</th><td>${uniqueCount.toLocaleString()}</td></tr>
          <tr><th class="text-muted">Uniqueness</th><td>${percent(uniqueCount, filled)}</td></tr>
        </tbody>
      </table>
    </div>
  `;

  // 3) Summary (type specific)
  if (isNumeric) {
    const nums = nonNull.map(Number).filter(v => !Number.isNaN(v)).sort((a,b)=>a-b);
    const n = nums.length;
    const mean = n ? nums.reduce((a,b)=>a+b,0)/n : 0;
    const std = (n>1) ? Math.sqrt(nums.reduce((s,v)=>s+(v-mean)**2,0)/(n-1)) : 0;
    const zeros = nums.filter(v => v === 0).length;
    const rsd = mean !== 0 ? (std/mean)*100 : 0;

    html += `
      <div>
        <h6 class="mb-1">Summary Statistics</h6>
        <table class="table table-sm mb-0">
          <tbody>
            <tr><th class="text-muted">Mean</th><td>${fmt(mean)}</td></tr>
            <tr><th class="text-muted">Min</th><td>${fmt(nums[0])}</td></tr>
            <tr><th class="text-muted">Max</th><td>${fmt(nums[n-1])}</td></tr>
            <tr><th class="text-muted">Std Dev</th><td>${fmt(std)}</td></tr>
            <tr><th class="text-muted">Relative Std Dev</th><td>${fmt(rsd,1)}%</td></tr>
            <tr><th class="text-muted">Zero Values</th><td>${zeros.toLocaleString()} (${percent(zeros, n)})</td></tr>
            <tr><th class="text-muted">25%</th><td>${fmt(qtile(nums, 0.25))}</td></tr>
            <tr><th class="text-muted">50% (Median)</th><td>${fmt(qtile(nums, 0.50))}</td></tr>
            <tr><th class="text-muted">75%</th><td>${fmt(qtile(nums, 0.75))}</td></tr>
          </tbody>
        </table>
      </div>
    `;
  } else if (isDate) {
    const dates = nonNull.map(v => new Date(v)).filter(d => !isNaN(d)).sort((a,b)=>a-b);
    const uniq = new Set(dates.map(d => d.getTime()));
    html += `
      <div>
        <h6 class="mb-1">Summary (Date)</h6>
        <table class="table table-sm mb-0">
          <tbody>
            <tr><th class="text-muted">Count</th><td>${dates.length.toLocaleString()}</td></tr>
            <tr><th class="text-muted">Unique</th><td>${uniq.size.toLocaleString()}</td></tr>
            <tr><th class="text-muted">Min</th><td>${dates.length ? toISO(dates[0]) : 'â€”'}</td></tr>
            <tr><th class="text-muted">Max</th><td>${dates.length ? toISO(dates[dates.length-1]) : 'â€”'}</td></tr>
          </tbody>
        </table>
      </div>
    `;
  } else {
    // categorical / text
    const counts = new Map();
    asStr.forEach(v => counts.set(v, (counts.get(v)||0)+1));
    let topVal = 'â€”', topFreq = 0;
    for (const [k,v] of counts.entries()) if (v > topFreq) { topVal = k; topFreq = v; }

    html += `
      <div>
        <h6 class="mb-1">Summary (Categorical/Text)</h6>
        <table class="table table-sm mb-0">
          <tbody>
            <tr><th class="text-muted">Count</th><td>${asStr.length.toLocaleString()}</td></tr>
            <tr><th class="text-muted">Unique</th><td>${counts.size.toLocaleString()}</td></tr>
            <tr><th class="text-muted">Top</th><td>${topVal}</td></tr>
            <tr><th class="text-muted">Freq</th><td>${topFreq.toLocaleString()} (${percent(topFreq, asStr.length)})</td></tr>
          </tbody>
        </table>
      </div>
    `;
  }

  id('fieldStats').innerHTML = html;
}

function fmt(x) {
  if (x === undefined || x === null || Number.isNaN(x)) return 'â€”';
  return Number(x).toLocaleString(undefined, { maximumFractionDigits: 3 });
}
function quantile(sortedNums, q) {
  if (!sortedNums.length) return NaN;
  const pos = (sortedNums.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if (sortedNums[base+1] !== undefined) {
    return sortedNums[base] + rest * (sortedNums[base+1] - sortedNums[base]);
  }
  return sortedNums[base];
}
  
    // ----------------------------
    // Utilities
    // ----------------------------
    const id = (s) => document.getElementById(s);
    const toISO = (d) => new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().split('T')[0];
    const uniqueNonEmpty = (arr) => Array.from(new Set(arr.map(v => v===null||v===undefined?'' : String(v)).filter(s => s !== ''))).sort();

    /**
     * Safely parse a date value. Returns a Date object if the input can be
     * converted to a valid date and the year falls within an acceptable
     * window (2000â€“2050). If the value is invalid or outâ€‘ofâ€‘range this
     * returns null. Using this helper prevents bogus dates such as 1970/2030
     * from creeping into our date range calculations.
     * @param {any} v
     * @returns {Date|null}
     */
    function parseValidDate(v) {
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return null;
      const y = d.getUTCFullYear();
      return (y >= 2000 && y <= 2050) ? d : null;
    }

    function appendOption(sel, value, label) {
      const o = document.createElement('option');
      o.value = value; o.textContent = label ?? value;
      sel.appendChild(o);
    }
    function fillMultiSelect(sel, values) {
      sel.innerHTML = '';
      for (const v of values) {
        const o = document.createElement('option');
        o.value = v; o.textContent = v; o.selected = true;
        sel.appendChild(o);
      }
    }
    function selectAll(sel){ for (const o of sel.options) o.selected = true; sel.dispatchEvent(new Event('change')); }
    function clearAll(sel){ for (const o of sel.options) o.selected = false; sel.dispatchEvent(new Event('change')); }

    function toggle(panelId) {
      const el = id(panelId);
      el.classList.toggle('active');
    }
    function show(panelId, on=true) {
      const el = id(panelId);
      if (on) el.classList.add('active'); else el.classList.remove('active');
    }
    function openModal(){ id('modal').style.display = 'grid'; }
    function closeModal(){ id('modal').style.display = 'none'; }


    function downloadCSV(filename, headers, rows) {
      const esc = (v) => {
        if (v === null || v === undefined) return '';
        const s = String(v);
        return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
      };
      const csv = [headers.map(esc).join(',')]
        .concat(rows.map(row => row.map(esc).join(',')))
        .join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
    }
   
  </script>
</body>
</html>
