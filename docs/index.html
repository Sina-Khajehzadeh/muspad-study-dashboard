<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MUSPAD Dynamic Dashboard</title>

  <!-- Bootstrap CSS + Icons (no SRI to avoid integrity mismatches) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
  
  <!-- Filters modal size fixes -->
  <link href="filters-size-fix.css" rel="stylesheet">

  <!-- Plotly.js for charts + PapaParse for CSV -->
  <script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Tiny inline favicon to avoid 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%23007bff'/%3E%3Ctext x='50%25' y='54%25' font-size='42' text-anchor='middle' fill='white'%3EM%3C/text%3E%3C/svg%3E"/>

  
  <style>
    :root {
      --sidebar-w: 50px;
      --card-min: 400px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Helvetica, sans-serif; overflow: hidden; }
    #app { display: flex; height: 100vh; overflow: hidden; }

    /* Sidebar */
    #sidebar {
      width: var(--sidebar-w);
      background: #f5f5f5;
      border-right: 1px solid #e1e1e1;
      display: flex; flex-direction: column; align-items: center; gap: .75rem;
      padding: .75rem .25rem;
    }
    #sidebar button {
      width: 36px; height: 36px; border: 0; background: transparent; border-radius: 8px;
      display: grid; place-items: center; font-size: 1.25rem; color: #333; cursor: pointer;
    }
    #sidebar button:hover { background: #e9ecef; color: #0d6efd; }

    /* Main column */
    #main { flex: 1; display: flex; flex-direction: column; min-width: 0; overflow: hidden; }

    /* Header */
    #header {
      display: flex; align-items: center; gap: 1rem;
      padding: .5rem 1rem; border-bottom: 1px solid #e1e1e1; background: #fff;
    }
    #title { margin: 0; font-size: 1.5rem; font-weight: 600; }
    #loadedBadge { font-size: .9rem; color: #6c757d; }
    .header-spacer { flex: 1; }
    .date-range { display: flex; gap: .5rem; }

    /* Panels */
    .panel { display: none; background: #f8f9fa; border-bottom: 1px solid #e1e1e1; padding: .75rem 1rem; overflow: auto; resize: both; position: relative; }
    .panel.active { display: block; }
    .panel h5 { margin-bottom: .75rem; }

    .filter-row { display: grid; grid-template-columns: 1fr auto auto; gap: .5rem; align-items: start; }
    .filter-actions .btn { white-space: nowrap; }

    /* Grid */
    #grid {
      flex: 1; overflow: auto; padding: 1rem;
      display: flex; flex-wrap: wrap; gap: 1rem;
    }
    .card-chart {
      width: calc(50% - .5rem);
      min-width: var(--card-min);
      background: #fff; border: 1px solid #e1e1e1; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,.06);
      resize: both; overflow: auto; position: relative;
    }
    .card-chart .card-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: .5rem .75rem; border-bottom: 1px solid #eee;
    }
    .card-chart .card-header h6 { margin: 0; font-size: 1rem; font-weight: 600; }
    .card-chart .remove { border: 0; background: transparent; color: #6c757d; font-size: 1.1rem; }
    .card-chart .remove:hover { color: #dc3545; }
    .card-chart .plot { height: 320px; padding: .5rem; }

    @media (max-width: 800px) {
      .card-chart { width: 100%; min-width: 100%; }
    }

    /* Global Filters Modal Size & Layout Fixes */
    
    /* Center the filters backdrop when shown */
    #filters-backdrop {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Override the filters panel max-width and improve responsive behavior */
    #filters-panel {
      width: min(1200px, 96vw) !important;
      max-width: min(1200px, 96vw) !important;
      resize: both !important;
    }
    
    /* Widen the left field list for better balance */
    #gf-field-list {
      min-width: 280px;
    }
    
    /* Improve right editor panel minimum width */
    #filters-panel .grid > div:last-child {
      min-width: 400px;
    }
    
    /* Better grid layout for larger modal */
    #filters-panel > div[style*="grid-template-columns"] {
      grid-template-columns: 300px 1fr !important;
      gap: 16px !important;
    }
    
    /* Media query for small screens */
    @media (max-width: 768px) {
      #filters-panel {
        width: 95vw !important;
        max-width: 95vw !important;
        margin: 10px;
      }
      
      #filters-panel > div[style*="grid-template-columns"] {
        grid-template-columns: 1fr !important;
        gap: 12px !important;
      }
      
      #gf-field-list {
        min-width: auto;
      }
    }

   

    /* Data Preview scroll helper */
    .data-preview-scroll {
      max-height: 520px;
      overflow-y: auto;
    }

    /* Resizable corner handle for visual cues */
    .resizable-corner {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      background: repeating-linear-gradient(
        -45deg,
        #ccc,
        #ccc 2px,
        transparent 2px,
        transparent 6px
      );
      cursor: nw-resize;
      pointer-events: none;
      z-index: 10;
      border-bottom-right-radius: 8px;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }
    .resizable-corner:hover {
      opacity: 1;
    }
    
    /* Make resize corners more visible on chart cards and panels */
    .card-chart .resizable-corner,
    .panel .resizable-corner {
      background: repeating-linear-gradient(
        -45deg,
        #007bff,
        #007bff 2px,
        transparent 2px,
        transparent 6px
      );
      opacity: 0.4;
    }
    .card-chart:hover .resizable-corner,
    .panel:hover .resizable-corner {
      opacity: 0.8;
    }

    /* Draggable card styles */
    .card-chart .card-header {
      cursor: move;
      user-select: none;
    }
    .card-chart.dragging {
      z-index: 1000;
      opacity: 0.8;
      transform: rotate(2deg);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      pointer-events: none;
    }
    .card-chart.dragging .card-header {
      cursor: grabbing;
    }
    /* Visual feedback for drag target area */
    #grid {
      position: relative;
    }

    /* Edit FAB (Floating Action Button) */
    .chart-edit-fab {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #007bff;
      color: white;
      border: none;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      z-index: 100;
      transition: all 0.2s ease;
      opacity: 0;
      transform: scale(0.8);
      box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
      tabindex: 0;
    }
    .chart-edit-fab:hover {
      background: #0056b3;
      transform: scale(1);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.4);
    }
    .chart-edit-fab:focus {
      outline: 2px solid #0056b3;
      outline-offset: 2px;
    }
    .chart-edit-fab.visible {
      display: flex;
      opacity: 1;
      transform: scale(1);
    }
    .card-chart {
      position: relative;
    }

    /* Modal */
    #modal {
      position: fixed; 
      inset: 0; 
      display: none; 
      place-items: center; 
      background: rgba(0,0,0,.45); 
      z-index: 1000;
      padding: 1rem;
    }
    #modal .sheet {
      width: min(600px, 100%); 
      max-width: 95vw; 
      max-height: 95vh; 
      background: #fff; 
      border-radius: 10px; 
      padding: 1rem 1rem 1.25rem;
      box-shadow: 0 8px 24px rgba(0,0,0,.2);
      resize: both;
      overflow: auto;
    }
    #modal .grid { display: grid; gap: .75rem; }
    #modal .actions { display: flex; justify-content: flex-end; gap: .5rem; margin-top: .75rem; }

    /* ===== Inspector panel styles START ===== */
    #dataLayout {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 1rem;
      min-height: 300px;
    }

    /* Right inspector panel */
    #inspector {
      background: #fff;
      border: 1px solid #e1e1e1;
      border-radius: 8px;
      padding: .75rem;
      box-shadow: 0 2px 4px rgba(0,0,0,.06);
      display: flex;
      flex-direction: column;
      gap: .75rem;
      max-height: 70vh;
      overflow-y: auto;
    }

    /* Blocks inside inspector */
    .inspector-block {
      border: 1px solid #f0f0f0;
      border-radius: 6px;
      padding: .5rem .6rem;
      background: #fafafa;
    }
    .inspector-title {
      margin: 0 0 .5rem 0;
      font-size: .95rem;
      font-weight: 600;
    }

    /* KPI grid */
    .inspector-kpis {
      display: grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: .5rem;
    }
    .kpi { background:#fff; border:1px solid #eee; border-radius:6px; padding:.4rem .5rem; }
    .kpi-wide { grid-column: 1 / -1; }
    .kpi-label { font-size:.75rem; color:#6c757d; }
    .kpi-value { font-weight:600; }

    /* Column list (scrollable) */
    .inspector-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: .35rem;
      max-height: 22vh;
      overflow: auto;
    }
    .inspector-list button {
      width: 100%;
      text-align: left;
      padding: .35rem .5rem;
      border: 1px solid #e1e1e1;
      background: #fff;
      border-radius: 6px;
      font-size: .9rem;
      cursor: pointer;
    }
    .inspector-list button:hover { background:#f5f8ff; border-color:#cfe2ff; }
    .inspector-list button.active { background:#e7f1ff; border-color:#9ec5fe; }

    /* Field stats area */
    #fieldStats {
      max-height: auto;
      overflow: auto;
      background:#fff;
      border:1px solid #eee;
      border-radius:6px;
      padding:.5rem;
    }

    /* Responsive */
    @media (max-width: 900px) {
      #dataLayout { grid-template-columns: 1fr; }
      #inspector { max-height: none; }
    }
    /* ===== Inspector panel styles END ===== */
  </style>
</head>
<body>
  <div id="app">
    <!-- Sidebar -->
    <aside id="sidebar" aria-label="Toolbar">
      <button id="btnFilters" title="Filters" aria-label="Filters"><i class="bi bi-funnel-fill"></i></button>
      <button id="btnData" title="Data table" aria-label="Data"><i class="bi bi-table"></i></button>
      <button id="btnSettings" title="Settings" aria-label="Settings"><i class="bi bi-gear-fill"></i></button>
      <button id="btnAdd" title="Add chart" aria-label="Add chart"><i class="bi bi-plus-lg"></i></button>
    </aside>

    <!-- Main -->
    <main id="main">
      <header id="header">
        <h1 id="title">MUSPAD Dynamic Dashboard</h1>
        <span id="loadedBadge" aria-live="polite"></span>
        <div class="header-spacer"></div>

        <!-- Date range (kept hidden) -->
        <div class="date-range" style="display:none">
          <input type="date" id="startDate" aria-label="Start date">
          <input type="date" id="endDate" aria-label="End date">
        </div>

        <button id="btnDownloadFiltered" type="button" class="btn btn-sm btn-outline-primary">
          Download filtered CSV
        </button>
      </header>

      <!-- Filters -->
      <section id="panelFilters" class="panel" aria-label="Filters">
        <h5 class="mb-3">Filters</h5>
        <div id="filter-container"></div>
        <div class="resizable-corner"></div>
      </section>

      <!-- Data table -->
      <section id="panelData" class="panel" aria-label="Data preview">
        <h5 class="mb-2">Data Preview</h5>

        <div id="dataLayout">
          <!-- LEFT: data table -->
          <div class="table-responsive" id="tableWrap"></div>

          <!-- RIGHT: inspector -->
          <aside id="inspector" aria-label="Variable Inspector & Dataset Summary">
            <div id="inspectorSummary" class="inspector-block">
              <h6 class="inspector-title">Dataset summary</h6>
              <div class="inspector-kpis">
                <div class="kpi"><div class="kpi-label">Total rows</div><div class="kpi-value" id="sumTotalRows">—</div></div>
                <div class="kpi"><div class="kpi-label">Total cols</div><div class="kpi-value" id="sumTotalCols">—</div></div>
                <div class="kpi"><div class="kpi-label">Filtered rows</div><div class="kpi-value" id="sumFilteredRows">—</div></div>
                <div class="kpi kpi-wide"><div class="kpi-label">Date range</div><div class="kpi-value" id="sumDateRange">—</div></div>
              </div>
            </div>

            <div id="inspectorCols" class="inspector-block">
              <h6 class="inspector-title">Columns</h6>
              <div id="inspectorList" class="inspector-list"></div>
            </div>

            <div id="inspectorDetails" class="inspector-block">
              <h6 class="inspector-title"><span id="fieldName">Select a column</span></h6>
              <div id="fieldStats">Choose a column from the list to see statistics.</div>
            </div>
          </aside>
        </div>
        <div class="resizable-corner"></div>
      </section>

      <!-- Settings -->
      <section id="panelSettings" class="panel" aria-label="Settings">
        <h5>Settings</h5>
        <p class="text-muted mb-0">Add theme/layout options here as needed.</p>
        <div class="resizable-corner"></div>
      </section>

      <!-- Chart grid -->
      <section id="grid" aria-label="Charts"></section>
    </main>
  </div>

  <!-- Chart Builder Modal -->
  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="sheet">
      <h5 id="modalTitle" class="mb-3">Create chart</h5>

      <!-- BASIC FIELDS -->
      <div class="grid">
        <div>
          <label class="form-label">Chart type</label>
          <select id="fldType" class="form-select">
            <option value="histogram">Histogram</option>
            <option value="bar">Column / Bar</option>
            <option value="barline">Bar + Line (combo)</option>
            <option value="pie">Pie Chart</option>
            <option value="timeseries">Time Series</option>
            <option value="line">Line Plot</option>
            <option value="heatmap">Heatmap</option>
            <option value="funnel">Funnel Chart</option>
            <option value="scatter">Scatter Plot</option>
            <option value="bubble">Bubble Chart</option>
            <option value="box">Box Plot</option>
            <option value="pivot">Pivot Table</option>
            <option value="datatable">Data Table</option>
          </select>
        </div>

        <div>
          <label class="form-label">X / Row / Category</label>
          <select id="fldX" class="form-select"></select>
        </div>

        <div data-role="needsNumeric">
          <label class="form-label">Y / Value (numeric)</label>
          <select id="fldY" class="form-select"></select>
        </div>

        <div data-role="needsSecondCat">
          <label class="form-label">Column (2nd category) — for Heatmap / Pivot</label>
          <select id="fldYCat" class="form-select"></select>
        </div>

        <div data-role="needsColor">
          <label class="form-label">Color / Group (optional)</label>
          <select id="fldColor" class="form-select"></select>
        </div>

        <div data-role="needsAgg">
          <label class="form-label">Aggregation</label>
          <select id="fldAgg" class="form-select">
            <option value="count">Count</option>
            <option value="sum">Sum</option>
            <option value="mean">Mean</option>
          </select>
        </div>

        <div data-role="needsY2">
          <label class="form-label">Y2 (numeric) — for Bar+Line</label>
          <select id="fldY2" class="form-select"></select>
        </div>

        <div data-role="needsSize">
          <label class="form-label">Size (numeric) — for Bubble</label>
          <select id="fldSize" class="form-select"></select>
        </div>

        <div data-role="comboToggles">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="chkDualAxis">
            <label class="form-check-label" for="chkDualAxis">Use dual Y-axis (Bar+Line)</label>
          </div>
          <div class="form-check" data-role="histToggle">
            <input class="form-check-input" type="checkbox" id="chkHistOverlay">
            <label class="form-check-label" for="chkHistOverlay">Add histogram overlay (Line / Box)</label>
          </div>
        </div>
      </div>

      <!-- ADVANCED SECTION -->
      <div class="mt-3">
        <div class="d-flex align-items-center">
          <h6 class="mb-0">Advanced</h6>
          <button type="button" id="btnToggleAdvanced" class="btn btn-link btn-sm ms-2 p-0" style="font-size: 0.8rem;">
            <i class="bi bi-chevron-down" id="iconAdvanced"></i> Show
          </button>
        </div>
        <div id="advancedSection" class="mt-2" style="display: none;">
          <div class="grid">
            <!-- X binning for numeric -->
            <div id="advancedXBinning" style="display: none;">
              <label class="form-label">X binning (nbins)</label>
              <input type="number" id="fldXBins" class="form-control" value="30" min="5" max="200">
            </div>

            <!-- X period for dates -->
            <div id="advancedXPeriod" style="display: none;">
              <label class="form-label">X period</label>
              <select id="fldXPeriod" class="form-select">
                <option value="day">Day</option>
                <option value="week">Week</option>
                <option value="month" selected>Month</option>
                <option value="quarter">Quarter</option>
                <option value="year">Year</option>
              </select>
            </div>

            <!-- X categorical order -->
            <div id="advancedXOrder" style="display: none;">
              <label class="form-label">X categorical order</label>
              <select id="fldXOrder" class="form-select">
                <option value="alphabetical" selected>Alphabetical</option>
                <option value="frequency_desc">Frequency (high to low)</option>
                <option value="frequency_asc">Frequency (low to high)</option>
              </select>
            </div>

            <!-- Categorical encoding -->
            <div id="advancedCategoricalEncoding">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="chkEncodeCategorical">
                <label class="form-check-label" for="chkEncodeCategorical">
                  Encode categorical X/Y (ordinal indices)
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="chkAddJitter">
                <label class="form-check-label" for="chkAddJitter">
                  Add jitter to points (scatter/line)
                </label>
              </div>
            </div>

            <!-- Histogram-specific options -->
            <div id="advancedHistogram" style="display: none;">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="chkShowRangeslider">
                <label class="form-check-label" for="chkShowRangeslider">
                  Show rangeslider
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- TRANSFORMATION SUMMARY -->
      <div class="mt-3">
        <div id="transformationSummary" class="alert alert-info py-2 px-3" style="font-size: 0.9rem; margin-bottom: 0;">
          Select chart type and fields to see transformation details.
        </div>
      </div>

      <div class="actions">
        <button id="btnCancel" class="btn btn-outline-secondary">Cancel</button>
        <button id="btnCreate" class="btn btn-primary">Create</button>
      </div>
      <div class="resizable-corner"></div>
    </div>
  </div>

  <!-- ==================== Main App Script ==================== -->
  <script>
  // ----------------------------
  // Global state
  // ----------------------------
  let rawData = [];
  let filtered = []; // Legacy variable, kept for backward compatibility
  let filteredRows = []; // Canonical source of truth for filtered dataset
  let columns = [];
  let charts = [];
  let dateCol = null;
  let ageCol  = null;
  let empCol  = null;
  let numericCols = [];
  let categoricalCols = [];
let inspectorSelectedField = null;

  // Edit mode state
  let editingChart = null; // Points to the chart config being edited

  // Simple filters state (for legacy selects and date range)
  let Simple = {
    dateRange: { start: null, end: null },
    categoryFilters: {} // { columnName: [selectedValues] }
  };

  // ----------------------------
  // Unified filtering helper functions
  // ----------------------------
  
  function passesSimpleFilters(row) {
    // Check date range filter
    if (dateCol && (Simple.dateRange.start || Simple.dateRange.end)) {
      const d = parseValidDate(row[dateCol]);
      if (!d) return false;
      if (Simple.dateRange.start && d < Simple.dateRange.start) return false;
      if (Simple.dateRange.end && d > Simple.dateRange.end) return false;
    }
    
    // Check category filters
    for (const col in Simple.categoryFilters) {
      const selected = Simple.categoryFilters[col];
      if (selected && selected.length > 0) {
        if (!selected.includes(String(row[col]))) return false;
      }
    }
    
    return true;
  }

  function passesGlobalFilters(row) {
    // If no Global Filters state, pass all rows
    if (!GF || !GF.state || Object.keys(GF.state).length === 0) {
      return true;
    }
    
    // Check each Global Filter
    for (const [col, sel] of Object.entries(GF.state)) {
      const v0 = row[col];
      const empty = (v0 === null || v0 === undefined || String(v0).trim() === '');

      if (sel.type === 'cat') {
        const hit = sel.include.has(String(v0));
        if (!hit && !(empty && sel.includeEmpty)) return false;
      }
      else if (sel.type === 'num') {
        if (empty) { 
          if (!sel.includeEmpty) return false; 
        } else {
          const num = Number(v0);
          if (Number.isNaN(num) || num < sel.min || num > sel.max) return false;
        }
      }
      else if (sel.type === 'date') {
        if (empty) { 
          if (!sel.includeEmpty) return false; 
        } else {
          const iso = new Date(v0).toISOString().slice(0, 10);
          if (sel.start && iso < sel.start) return false;
          if (sel.end && iso > sel.end) return false;
          if (sel.buckets && sel.buckets.size) {
            const y = iso.slice(0, 4);
            const ym = iso.slice(0, 7);
            const q = `Q${Math.floor((Number(iso.slice(5, 7)) - 1) / 3) + 1} ${y}`;
            const key = sel.period === 'quarter' ? q : (sel.period === 'year' ? y : ym);
            if (!sel.buckets.has(key)) return false;
          }
        }
      }
    }
    
    return true;
  }

  // Hash a string to a hue
  function hueFromString(s){
    let h = 0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) % 360;
    return h;
  }
  // Build a nice pastel palette from a hue
  function chipColors(h){
    return {
      bg: `hsl(${h} 80% 94%)`,
      fg: `hsl(${h} 28% 26%)`,
      border: `hsl(${h} 60% 85%)`,
      bgActive: `hsl(${h} 92% 90%)`,
      borderActive: `hsl(${h} 70% 76%)`,
      stripe: `hsl(${h} 80% 52%)`
    };
  }

  // ----------------------------
  // Boot
  // ----------------------------
  document.addEventListener('DOMContentLoaded', () => {
    wireUI();
    loadCSV();
    // Initialize Plotly resize observer after a short delay to ensure elements are rendered
    setTimeout(initPlotlyResizeObserver, 500);
    // Initialize dragging for any existing chart cards
    setTimeout(initExistingCardsDraggable, 600);
  });

  function wireUI() {
    // Sidebar toggles
    id('btnFilters').addEventListener('click', openFiltersModal);
    id('btnData').addEventListener('click', () => toggle('panelData'));
    id('btnSettings').addEventListener('click', () => toggle('panelSettings'));
    id('btnAdd').addEventListener('click', () => {
      resetModalToCreateMode();
      updateBuilderVisibility();
      openModal();
    });

    // Date change
    const startDateEl = id('startDate');
    const endDateEl = id('endDate');
    if (startDateEl) startDateEl.addEventListener('change', applyFilters);
    if (endDateEl) endDateEl.addEventListener('change', applyFilters);

    // Modal controls
    const btnCancel = id('btnCancel');
    const btnCreate = id('btnCreate');
    const modal = id('modal');
    
    if (btnCancel) btnCancel.addEventListener('click', () => {
      resetModalToCreateMode();
      closeModal();
    });
    if (btnCreate) btnCreate.addEventListener('click', () => {
      if (editingChart) {
        // Update existing chart
        readBuilderToConfig(editingChart);
        // Update title in case it changed
        const titleEl = editingChart._card.querySelector('.card-header h6');
        if (titleEl) titleEl.textContent = titleFor(editingChart);
        // Redraw chart with new configuration
        drawChart(editingChart);
        resetModalToCreateMode();
      } else {
        // Create new chart
        const cfg = {
          type:    id('fldType')?.value || 'bar',
          x:       id('fldX')?.value || null,
          y:       id('fldY')?.value || null,
          y2:      id('fldY2')?.value || null,
          yCat:    id('fldYCat')?.value || null,
          color:   id('fldColor')?.value || null,
          size:    id('fldSize')?.value || null,
          agg:     id('fldAgg')?.value || 'count',
          dualAxis:    id('chkDualAxis')?.checked || false,
          histOverlay: id('chkHistOverlay')?.checked || false,
          // Advanced options
          xBins:       parseInt(id('fldXBins')?.value) || 30,
          xPeriod:     id('fldXPeriod')?.value || 'month',
          xOrder:      id('fldXOrder')?.value || 'alphabetical',
          encodeCategorical: id('chkEncodeCategorical')?.checked || false,
          addJitter:   id('chkAddJitter')?.checked || false,
          showRangeslider: id('chkShowRangeslider')?.checked || false
        };
        addChart(cfg);
      }
      closeModal();
    });

    // Close builder by clicking backdrop
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          resetModalToCreateMode();
          closeModal();
        }
      });
    }

    // Update builder visibility when chart type changes
    const fldType = id('fldType');
    if (fldType) {
      fldType.addEventListener('change', () => {
        updateBuilderVisibility();
        updateAdvancedVisibility();
        updateTransformationSummary();
      });
      updateBuilderVisibility();
      updateAdvancedVisibility();
    }
    
    // Wire up field changes to update transformation summary
    ['fldX', 'fldY', 'fldColor', 'fldXBins', 'fldXPeriod', 'fldXOrder'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('change', () => {
          updateAdvancedVisibility();
          updateTransformationSummary();
        });
      }
    });
    
    ['chkEncodeCategorical', 'chkAddJitter', 'chkShowRangeslider'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('change', updateTransformationSummary);
      }
    });
    
    // Advanced section toggle
    const btnToggleAdvanced = id('btnToggleAdvanced');
    const advancedSection = id('advancedSection');
    const iconAdvanced = id('iconAdvanced');
    if (btnToggleAdvanced && advancedSection) {
      btnToggleAdvanced.addEventListener('click', () => {
        const isHidden = advancedSection.style.display === 'none';
        advancedSection.style.display = isHidden ? 'block' : 'none';
        iconAdvanced.className = isHidden ? 'bi bi-chevron-up' : 'bi bi-chevron-down';
        btnToggleAdvanced.textContent = isHidden ? ' Hide' : ' Show';
      });
    }
     
    // Download filtered CSV
    const btnDownload = id('btnDownloadFiltered');
    if (btnDownload) {
      btnDownload.addEventListener('click', () => {
        if (!filteredRows || !filteredRows.length) {
          alert('No rows in the current filter.');
          return;
        }
        downloadCSV('filtered_data.csv', columns, filteredRows.map(r => columns.map(c => r[c])));
      });
    }
  }

  // ----------------------------
  // Builder field visibility
  // ----------------------------
  function updateBuilderVisibility() {
    const typeEl = id('fldType');
    if (!typeEl) return;
    
    const type = typeEl.value;
    const show = (selector, on) => {
      document.querySelectorAll(selector).forEach(el => {
        if (el) el.style.display = on ? '' : 'none';
      });
    };
    
    // Show/hide fields based on chart type
    show('[data-role="needsNumeric"]', !['pie','heatmap','pivot','datatable','funnel','histogram'].includes(type));
    show('[data-role="needsAgg"]', !['scatter','bubble','box','datatable','pivot','histogram'].includes(type));
    show('[data-role="needsColor"]', ['bar','line','scatter','bubble','box','barline','histogram'].includes(type));
    show('[data-role="needsSecondCat"]', ['heatmap','pivot'].includes(type));
    show('[data-role="needsY2"]', type === 'barline');
    show('[data-role="needsSize"]', type === 'bubble');
    show('[data-role="comboToggles"]', ['barline','line','box'].includes(type));
    show('[data-role="histToggle"]', ['line','box'].includes(type));
  }

  // ----------------------------
  // Data loading (with fallbacks)
  // ----------------------------
  
  function generateSampleData() {
    const sampleData = [];
    const categories = ['Category A', 'Category B', 'Category C', 'Category D'];
    const regions = ['North', 'South', 'East', 'West'];
    const dates = ['2023-01-01', '2023-02-01', '2023-03-01', '2023-04-01', '2023-05-01'];
    
    for (let i = 0; i < 100; i++) {
      // Generate vaccination dates for testing dose_interval_days
      const firstVaccDate = new Date(2023, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1);
      const daysInterval = Math.floor(Math.random() * 60) + 14; // 14-74 days interval
      const secondVaccDate = new Date(firstVaccDate.getTime() + daysInterval * 24 * 60 * 60 * 1000);
      
      // Add some invalid data to test filtering
      let X20_21_vacc_first_date, X20_21_vacc_second_date;
      if (Math.random() < 0.1) {
        // 10% invalid first dates  
        X20_21_vacc_first_date = ['', null, 'invalid-date', undefined][Math.floor(Math.random() * 4)];
        X20_21_vacc_second_date = secondVaccDate.toISOString().split('T')[0];
      } else if (Math.random() < 0.1) {
        // 10% invalid second dates
        X20_21_vacc_first_date = firstVaccDate.toISOString().split('T')[0];
        X20_21_vacc_second_date = ['', null, 'invalid-date', undefined][Math.floor(Math.random() * 4)];
      } else {
        // 80% valid dates
        X20_21_vacc_first_date = firstVaccDate.toISOString().split('T')[0];
        X20_21_vacc_second_date = secondVaccDate.toISOString().split('T')[0];
      }
      
      sampleData.push({
        id: i + 1,
        category: categories[Math.floor(Math.random() * categories.length)],
        region: regions[Math.floor(Math.random() * regions.length)],
        value: Math.floor(Math.random() * 1000) + 100,
        date: dates[Math.floor(Math.random() * dates.length)],
        score: Math.random() * 100,
        X20_21_vacc_first_date: X20_21_vacc_first_date,
        X20_21_vacc_second_date: X20_21_vacc_second_date
      });
    }
    
    rawData = sampleData;
    columns = Object.keys(sampleData[0]);
    
    // Compute dose_interval_days derived column
    computeDoseIntervalDays();
    
    id('loadedBadge').textContent = `Loaded ${rawData.length.toLocaleString()} rows • ${columns.length} columns (Sample Data)`;

    detectColumns();
    populateFilters();
    populateBuilderSelects();

    rebuildInspectorColumnList();
    updateInspectorSummary();

    show('panelData', true);
    applyFilters();
    
    autoStarterCharts();
    initGlobalFilters();
  }
  
  function loadCSV() {
    // Try to load real CSV data first
    const urls = [
      'https://raw.githubusercontent.com/Sina-Khajehzadeh/muspad-study-dashboard/main/docs/data/df3_full_for_pivot.csv',
      'https://sina-khajehzadeh.github.io/muspad-study-dashboard/data/df3_full_for_pivot.csv',
      'data/df3_full_for_pivot.csv'
    ];

    let idx = 0;
    const tryNext = () => {
      if (idx >= urls.length) {
        console.log('All CSV sources failed. Using sample data as fallback.');
        generateSampleData();
        return;
      }
      const url = urls[idx++];
      console.log('Trying to load data from', url);
      Papa.parse(url, {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: true,
        worker: false,
        
        transformHeader: (h) => (h || '').replace(/^\uFEFF/, '').trim(),
        complete: (res) => {
          if (!res || !Array.isArray(res.data) || res.data.length === 0) {
            console.warn('Parsed but empty. Trying next source…');
            tryNext();
            return;
          }
          console.log('Successfully loaded CSV data:', res.data.length, 'rows');
          rawData = res.data;
          columns = (res.meta && res.meta.fields && res.meta.fields.length)
            ? res.meta.fields
            : Object.keys(rawData[0] || {});
          
          // Compute dose_interval_days derived column
          computeDoseIntervalDays();
          
          id('loadedBadge').textContent = `Loaded ${rawData.length.toLocaleString()} rows • ${columns.length} columns`;

          detectColumns();
          populateFilters();
          populateBuilderSelects();

          rebuildInspectorColumnList();
          updateInspectorSummary();

          show('panelData', true);
          applyFilters();
          
          autoStarterCharts();
          initGlobalFilters();
        },
        error: (err) => {
          console.error('Papa error:', err);
          tryNext();
        }
      });
     
    };            // ✅ closes tryNext

  tryNext();    // ✅ call it OUTSIDE the function body
}               // ✅ closes loadCSV

  // ----------------------------
  // Helper utilities for type-agnostic chart building
  // ----------------------------

  function isDateCol(col) {
    // First check if it's in the detected date columns
    if (col === dateCol) return true;
    
    // Check column name hints
    const nameHint = /(date|time|_dt|_time|timestamp)/i;
    if (nameHint.test(col)) return true;
    
    // Sample values and check if they parse as dates in a reasonable range
    const vals = sampleValues(col, 100);
    let parsed = 0, withinRange = 0;
    for (const v of vals) {
      const d = new Date(v);
      if (!isNaN(d)) {
        parsed++;
        const y = d.getUTCFullYear();
        if (y >= 2010 && y <= 2030) withinRange++;
      }
    }
    const rate = vals.length ? parsed / vals.length : 0;
    const rangeRate = vals.length ? withinRange / vals.length : 0;
    return rate >= 0.7 && rangeRate >= 0.7;
  }

  function encodeCategorical(arr) {
    // Create ordinal mapping for categorical values
    const unique = [...new Set(arr.filter(v => v != null && v !== ''))];
    const valueToIndex = new Map();
    const ticks = [];
    
    unique.forEach((val, idx) => {
      valueToIndex.set(String(val), idx);
      ticks.push({ value: idx, label: String(val) });
    });
    
    const values = arr.map(v => 
      v == null || v === '' ? null : valueToIndex.get(String(v))
    );
    
    return { values, ticks };
  }

  function jitter(values, amplitude = 0.2) {
    // Add small random noise to encoded categorical values
    return values.map(v => 
      v == null ? null : v + (Math.random() - 0.5) * amplitude
    );
  }

  function binNumeric(values, nbins = 30) {
    // Bin numeric values into histogram bins
    const validVals = values.filter(v => typeof v === 'number' && !isNaN(v));
    if (validVals.length === 0) return { bins: [], counts: [] };
    
    const min = Math.min(...validVals);
    const max = Math.max(...validVals);
    const range = max - min;
    const binWidth = range / nbins;
    
    const bins = [];
    const counts = [];
    
    for (let i = 0; i < nbins; i++) {
      const binStart = min + i * binWidth;
      const binEnd = min + (i + 1) * binWidth;
      const binCenter = (binStart + binEnd) / 2;
      bins.push(binCenter);
      
      const count = validVals.filter(v => 
        i === nbins - 1 ? v >= binStart && v <= binEnd : v >= binStart && v < binEnd
      ).length;
      counts.push(count);
    }
    
    return { bins, counts, min, max, binWidth };
  }

  function binDates(values, period = 'month') {
    // Group date values by specified period
    const groups = new Map();
    
    values.forEach(v => {
      if (!v) return;
      const d = new Date(v);
      if (isNaN(d)) return;
      
      let key;
      const year = d.getUTCFullYear();
      const month = String(d.getUTCMonth() + 1).padStart(2, '0');
      
      switch (period) {
        case 'day':
          key = d.toISOString().slice(0, 10);
          break;
        case 'week':
          const weekStart = new Date(d);
          weekStart.setUTCDate(d.getUTCDate() - d.getUTCDay());
          key = weekStart.toISOString().slice(0, 10);
          break;
        case 'month':
          key = `${year}-${month}`;
          break;
        case 'quarter':
          const quarter = Math.floor((d.getUTCMonth() + 3) / 3);
          key = `Q${quarter} ${year}`;
          break;
        case 'year':
          key = String(year);
          break;
        default:
          key = `${year}-${month}`;
      }
      
      groups.set(key, (groups.get(key) || 0) + 1);
    });
    
    const labels = Array.from(groups.keys()).sort();
    const counts = labels.map(label => groups.get(label));
    
    return { labels, counts };
  }

  function getColumnType(col) {
    // Determine if column is numeric, categorical, or date
    if (isDateCol(col)) return 'date';
    if (looksNumericColumn(col)) return 'numeric';
    if (looksCategoricalColumn(col)) return 'categorical';
    return 'other';
  }

  function computeDoseIntervalDays() {
    // Compute dose_interval_days as difference between second and first vaccination dates
    const firstDateCols = [
      'X20_21_vacc_first_date',
      'vacc_first_date', 
      'first_vaccination_date',
      'first_dose_date'
    ];
    const secondDateCols = [
      'X20_21_vacc_second_date',
      'vacc_second_date',
      'second_vaccination_date', 
      'second_dose_date'
    ];
    
    const firstDateCol = firstDateCols.find(col => columns.includes(col));
    const secondDateCol = secondDateCols.find(col => columns.includes(col));
    
    if (firstDateCol && secondDateCol) {
      console.log(`Computing dose_interval_days from ${firstDateCol} and ${secondDateCol}`);
      
      rawData.forEach(row => {
        const firstDateVal = row[firstDateCol];
        const secondDateVal = row[secondDateCol];
        
        // Check for null/undefined values before creating Date objects
        if (firstDateVal != null && firstDateVal !== '' && 
            secondDateVal != null && secondDateVal !== '') {
          
          const firstDate = new Date(firstDateVal);
          const secondDate = new Date(secondDateVal);
          
          if (!isNaN(firstDate) && !isNaN(secondDate)) {
            const diffTime = secondDate.getTime() - firstDate.getTime();
            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
            row.dose_interval_days = diffDays;
          } else {
            row.dose_interval_days = null;
          }
        } else {
          row.dose_interval_days = null;
        }
      });
      
      // Add to columns if not already present
      if (!columns.includes('dose_interval_days')) {
        columns.push('dose_interval_days');
      }
    }
  }

  // ----------------------------
  // Color utilities
  // ----------------------------
  function hueFromString(s){
    let h = 0;
    for (let i=0; i<s.length; i++) h = (h*31 + s.charCodeAt(i)) % 360;
    return h;
  }
  function chipColors(h){
    return {
      bg: `hsl(${h} 80% 94%)`,
      fg: `hsl(${h} 28% 26%)`,
      border: `hsl(${h} 60% 85%)`,
      bgActive: `hsl(${h} 92% 90%)`,
      borderActive: `hsl(${h} 70% 76%)`,
      stripe: `hsl(${h} 80% 52%)`
    };
  }
    
  // ----------------------------
  // Global Filters Implementation
  // ----------------------------
  
  let GF = {
    state: {},         // { fieldKey: {type:'cat'|'num'|'date', ...selection...} }
    meta: {},          // { fieldKey: {type, empties, uniques:[{v,count}], min,max, domainDates:[...]} }
    activeField: null, // string
    _group: 'all'      // current group filter
  };

  function gf_inferType(values) {
    // decide cat/num/date
    let n = 0, d = 0, c = 0;
    for (const v of values) {
      if (v === null || v === undefined || v === '') continue;
      const s = String(v).trim();
      if (s === '') continue;
      const num = Number(s);
      if (!Number.isNaN(num) && isFinite(num)) { n++; continue; }
      const dt = new Date(s);
      if (!isNaN(dt.getTime())) { d++; continue; }
      c++;
      if (n + d + c > 30) break;
    }
    if (n && !d && !c) return 'num';
    if (d && !n && !c) return 'date';
    // tie-break: many dashboards prefer treating mixed as categories
    if (n > d && n > c) return 'num';
    if (d > n && d > c) return 'date';
    return 'cat';
  }

  function gf_buildMeta() {
    GF.meta = {};
    const N = rawData.length;
    columns.forEach(col => {
      const vals = rawData.map(r => r[col]);
      const type = gf_inferType(vals);
      const m = GF.meta[col] = { type, empties:0, uniques:[], min:null, max:null, buckets:{} };
      const counts = new Map();
      for (const v0 of vals) {
        let v = v0;
        if (v === undefined || v === null || String(v).trim() === '') { m.empties++; continue; }
        if (type === 'num') {
          const num = Number(v);
          if (!Number.isNaN(num) && isFinite(num)) {
            if (m.min === null || num < m.min) m.min = num;
            if (m.max === null || num > m.max) m.max = num;
            v = num;
          } else { m.empties++; continue; }
        } else if (type === 'date') {
          const dt = new Date(v);
          if (isNaN(dt.getTime())) { m.empties++; continue; }
          v = dt.toISOString().slice(0,10); // YYYY-MM-DD
        } else {
          v = String(v);
        }
        counts.set(v, (counts.get(v) || 0) + 1);
      }
      m.uniques = [...counts.entries()].map(([v,count])=>({v,count}));
      if (type === 'num') {
        const binCount = 7;
        const width = (m.max - m.min) / binCount || 1;
        m.binCounts = Array(binCount).fill(0);
        for (const [val,count] of counts.entries()) {
          const idx = Math.min(binCount-1, Math.floor((val - m.min) / width));
          m.binCounts[idx] += count;
        }
      }    
      // precompute date buckets
      if (type === 'date') {
        const toQuarter = (iso) => {
          const y = Number(iso.slice(0,4));
          const m = Number(iso.slice(5,7));
          const q = Math.floor((m-1)/3)+1;
          return `Q${q} ${y}`;
        };
        const toYear = (iso) => iso.slice(0,4);
        const toMonth = (iso) => iso.slice(0,7); // YYYY-MM
        for (const {v,count} of m.uniques) {
          const q = toQuarter(v); m.buckets[q] = (m.buckets[q]||0)+count;
          const y = toYear(v);    m.buckets[y] = (m.buckets[y]||0)+count;
          const mo = toMonth(v);  m.buckets[mo] = (m.buckets[mo]||0)+count;
        }
      }
    });
  }

  function gf_renderSelectedChips(live = false) {
    const chipsContainer = document.getElementById('gf-selected-chips');
    const chipsList = document.getElementById('gf-selected-chips-list');
    
    if (!chipsContainer || !chipsList) return;
    
    chipsList.innerHTML = '';
    
    const hasFilters = Object.keys(GF.state).length > 0;
    chipsContainer.style.display = hasFilters ? 'block' : 'none';
    
    if (!hasFilters) {
      chipsList.innerHTML = '<span style="color:var(--gf-muted,#6b7280); font-size:14px; font-style:italic;">No filters applied</span>';
      if (live) {
        // Use unified pipeline for live preview with no filters
        applyFiltersPipeline(true);
      }
      return;
    }
    
    for (const [fieldName, filter] of Object.entries(GF.state)) {
      const chip = document.createElement('div');
      chip.className = 'gf-selected-chip';
      
      // Set chip colors based on field name hash
      const h = hueFromString(fieldName);
      const colors = chipColors(h);
      chip.style.setProperty('--chip-bg', colors.bg);
      chip.style.setProperty('--chip-fg', colors.fg);
      chip.style.setProperty('--chip-border', colors.border);
      chip.style.setProperty('--chip-bg-hover', colors.bgActive);
      chip.style.setProperty('--chip-border-hover', colors.borderActive);
      
      // Build constraint text
      let constraintText = '';
      if (filter.type === 'cat') {
        const includeCount = filter.include ? filter.include.size : 0;
        const emptyText = filter.includeEmpty ? ' + [EMPTY]' : '';
        constraintText = includeCount > 0 ? `${includeCount} values${emptyText}` : (filter.includeEmpty ? '[EMPTY] only' : 'none');
      } else if (filter.type === 'num') {
        const minVal = filter.min !== undefined ? filter.min : 'min';
        const maxVal = filter.max !== undefined ? filter.max : 'max';
        const emptyText = filter.includeEmpty ? ' + [EMPTY]' : '';
        constraintText = `${minVal} – ${maxVal}${emptyText}`;
      } else if (filter.type === 'date') {
        const bucketsCount = filter.buckets ? filter.buckets.size : 0;
        const emptyText = filter.includeEmpty ? ' + [EMPTY]' : '';
        constraintText = bucketsCount > 0 ? `${bucketsCount} ${filter.period}s${emptyText}` : 
                        (filter.start || filter.end ? `${filter.start || '…'} → ${filter.end || '…'}${emptyText}` : 
                        (filter.includeEmpty ? '[EMPTY] only' : 'none'));
      }
      
      chip.innerHTML = `
        <span class="gf-field-name">${fieldName}</span>
        <span class="gf-constraint-text">${constraintText}</span>
        <button class="gf-selected-chip-remove" onclick="gf_removeFilter('${fieldName}')" aria-label="Remove ${fieldName} filter" title="Remove filter">×</button>
      `;
      
      chipsList.appendChild(chip);
    }
    
    // Live preview functionality
    if (live) {
      // Use the unified filter pipeline for live preview
      applyFiltersPipeline(true);
    }
  }

  function gf_removeFilter(fieldName) {
    delete GF.state[fieldName];
    gf_renderSelectedChips(true);
    
    // If this field is currently active, refresh its display
    if (GF.activeField === fieldName) {
      gf_showField(fieldName);
    }
    
    // Update field list to reflect changes
    gf_renderFieldList(GF._group || 'all', document.getElementById('gf-field-search')?.value || '');
    
    // Apply live filter pipeline
    applyFiltersPipeline(true);
  }

  function openFiltersModal() {
    const el = document.getElementById('filters-backdrop');
    if (el) {
      el.classList.add('show');
      document.body.style.overflow = 'hidden';
      document.addEventListener('keydown', filtersEscHandler);
      // left list
      gf_renderFieldList('all', '');
      // right pane
      gf_showField(null);
      // render selected chips
      gf_renderSelectedChips();
    }
  }
  
  function closeFiltersModal() {
    const el = document.getElementById('filters-backdrop');
    if (el) {
      el.classList.remove('show');
      document.body.style.overflow = '';
      document.removeEventListener('keydown', filtersEscHandler);
    }
  }

  function filtersEscHandler(e) {
    if (e.key === 'Escape') {
      closeFiltersModal();
    }
  }

  function gf_initUI() {
    // hook your existing sidebar filter icon (id="btnFilters" in your code)
    const btn = document.getElementById('btnFilters') || document.querySelector('[data-action="filters"]');
    if (btn) btn.addEventListener('click', openFiltersModal);
    
    // Add click outside to close
    const backdrop = document.getElementById('filters-backdrop');
    if (backdrop) {
      backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) {
          closeFiltersModal();
        }
      });
    }

    const cancelBtn = document.getElementById('gf-cancel');
    const clearBtn = document.getElementById('gf-clear-all');
    const applyBtn = document.getElementById('gf-apply');
    
    if (cancelBtn) cancelBtn.onclick = closeFiltersModal;
    if (clearBtn) clearBtn.onclick = () => { 
      GF.state = {}; 
      gf_renderFieldList(GF._group||'all', document.getElementById('gf-field-search').value||''); 
      gf_showField(GF.activeField); 
      gf_renderSelectedChips();
      applyFiltersPipeline(true);
    };
    if (applyBtn) applyBtn.onclick = applyGlobalFilters;

    // groups
    const groupButtons = document.querySelectorAll('#gf-groups button');
    groupButtons.forEach(b=>{
      b.onclick = ()=>{
        groupButtons.forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        GF._group = b.dataset.group;
        gf_renderFieldList(GF._group, document.getElementById('gf-field-search').value||'');
      };
    });

    // search fields
    const fieldSearch = document.getElementById('gf-field-search');
    if (fieldSearch) {
      fieldSearch.oninput = (e)=>{
        gf_renderFieldList(GF._group||'all', e.target.value||'');
      };
    }

    // sort/search on values
    const sortSelect = document.getElementById('gf-sort');
    const valueSearch = document.getElementById('gf-value-search');
    
    if (sortSelect) sortSelect.onchange = ()=> gf_showField(GF.activeField);
    if (valueSearch) valueSearch.oninput = ()=> gf_showField(GF.activeField);
  }

  function gf_renderFieldList(group, needle) {
    if (!GF.meta || !columns?.length) return;
    const wrap = document.getElementById('gf-field-list');
    if (!wrap) return;
    
    wrap.innerHTML = '';
    const list = [];
    for (const col of columns) {
      const t = GF.meta?.[col]?.type || 'cat';
      if (group!=='all' && ((group==='cat'&&t!=='cat')||(group==='num'&&t!=='num')||(group==='date'&&t!=='date'))) continue;
      if (needle && !col.toLowerCase().includes(needle.toLowerCase())) continue;
      list.push({col, t});
    }
    list.sort((a,b)=>a.col.localeCompare(b.col));
    for (const {col,t} of list) {
      const a = document.createElement('div');
      a.className = 'gf-field-item';
      a.style.setProperty('--stripe', chipColors(hueFromString(col)).stripe);
      a.textContent = `${col}  ·  ${t}`;
      a.onclick = ()=>{ 
        GF.activeField = col; 
        gf_showField(col);
        wrap.querySelectorAll('.gf-field-item').forEach(x=>x.classList.remove('active'));
        a.classList.add('active');
      };      
      a.innerHTML = `<span class="gf-name">${col}</span>` +
               `<span class="gf-count">${GF.meta?.[col]?.uniques?.length ?? ''}</span>`;
      wrap.appendChild(a);
    }
  }

  function gf_showField(col) {
    const chipWrap = document.getElementById('gf-chip-wrap');
    const numWrap = document.getElementById('gf-num-wrap');
    const dateWrap = document.getElementById('gf-date-wrap');
    const help = document.getElementById('gf-help');
    const activeField = document.getElementById('gf-active-field');
    
    if (chipWrap) chipWrap.style.display='none';
    if (numWrap) numWrap.style.display='none';
    if (dateWrap) dateWrap.style.display='none';
    if (help) help.style.display = col ? 'none' : 'block';
    if (activeField) activeField.textContent = col || '(Select a field)';

    if (!col) return;
    const meta = GF.meta?.[col];
    const sortSelect = document.getElementById('gf-sort');
    const valueSearch = document.getElementById('gf-value-search');
    const sort = sortSelect ? sortSelect.value : 'count';
    const filterText = (valueSearch ? valueSearch.value : '').toLowerCase();

    if (meta.type==='cat') {
      const box = document.getElementById('gf-chip-wrap');
      if (!box) return;
      box.innerHTML = '';
      let items = meta.uniques.slice();
      if (filterText) items = items.filter(x=>String(x.v).toLowerCase().includes(filterText));
      if (sort==='count') items.sort((a,b)=>b.count-a.count);
      if (sort==='az') items.sort((a,b)=>String(a.v).localeCompare(String(b.v)));
      if (sort==='za') items.sort((a,b)=>String(b.v).localeCompare(String(a.v)));

      const current = GF.state[col]?.include || new Set();
      const toggle = (val)=>{
        if (!GF.state[col]) GF.state[col] = {type:'cat', include:new Set(), includeEmpty:false};
        if (current.has(val)) current.delete(val); else current.add(val);
        gf_showField(col);
        gf_renderSelectedChips(true);
        applyFiltersPipeline(true);
      };

      items.forEach(({v,count})=>{
          const chip = document.createElement('button');
          chip.type = 'button';
          chip.className = 'gf-chip ' + (current.has(v)?'active':'');
          const h = hueFromString(String(v));
          const C = chipColors(h);
          chip.style.setProperty('--chip-bg', C.bg);
          chip.style.setProperty('--chip-fg', C.fg);
          chip.style.setProperty('--chip-border', C.border);
          chip.style.setProperty('--chip-bg-active', C.bgActive);
          chip.style.setProperty('--chip-border-active', C.borderActive);
          chip.textContent = `${v} `;
          const cnt = document.createElement('small');
          cnt.textContent = count.toLocaleString();
          chip.appendChild(cnt);
          chip.onclick = ()=>toggle(v);
          box.appendChild(chip);
                
      });
      // [EMPTY] - use consistent chip styling
      if (meta.empties>0) {
        const chip = document.createElement('span');
        const on = !!GF.state[col]?.includeEmpty;
        chip.className = 'gf-chip' + (on ? ' active' : '');
        chip.style.margin='4px';
        
        // Apply consistent colors based on field name + "empty"
        const h = hueFromString(col + '_empty');
        const colors = chipColors(h);
        chip.style.setProperty('--chip-bg', on ? colors.bgActive : colors.bg);
        chip.style.setProperty('--chip-fg', colors.fg);
        chip.style.setProperty('--chip-border', on ? colors.borderActive : colors.border);
        chip.style.setProperty('--chip-bg-active', colors.bgActive);
        chip.style.setProperty('--chip-border-active', colors.borderActive);
        
        chip.textContent = `[EMPTY] `;
        const countEl = document.createElement('small');
        countEl.textContent = meta.empties.toLocaleString();
        chip.appendChild(countEl);
        
        chip.onclick = ()=>{
          if (!GF.state[col]) GF.state[col] = {type:'cat', include:new Set(), includeEmpty:false};
          GF.state[col].includeEmpty = !GF.state[col].includeEmpty;
          gf_showField(col);
          gf_renderSelectedChips(true);
          applyFiltersPipeline(true);
        };
        box.appendChild(chip);
      }
      // select all/none
      const tools = document.createElement('div');
      tools.style.marginTop='8px';
      const allBtn = document.createElement('button'); allBtn.className='btn btn-xs btn-light'; allBtn.textContent='Select All';
      allBtn.onclick = ()=>{ GF.state[col]={type:'cat', include:new Set(items.map(x=>x.v)), includeEmpty:GF.state[col]?.includeEmpty||false}; gf_showField(col); gf_renderSelectedChips(true); applyFiltersPipeline(true); };
      const noneBtn = document.createElement('button'); noneBtn.className='btn btn-xs btn-light'; noneBtn.style.marginLeft='6px'; noneBtn.textContent='Deselect All';
      noneBtn.onclick = ()=>{ GF.state[col]={type:'cat', include:new Set(), includeEmpty:false}; gf_showField(col); gf_renderSelectedChips(true); applyFiltersPipeline(true); };
      tools.appendChild(allBtn); tools.appendChild(noneBtn); box.appendChild(tools);

      box.style.display='flex';

    } else if (meta.type === 'num') {
      const wrap = document.getElementById('gf-num-wrap');
      if (!wrap) return;
      wrap.style.display = 'flex';

      // state object for this field
      const s = GF.state[col] || { type: 'num', min: meta.min, max: meta.max, includeEmpty: false };
      GF.state[col] = s;

      // elements
      const minEl = document.getElementById('gf-num-min');
      const maxEl = document.getElementById('gf-num-max');
      const sMin = document.getElementById('gf-num-slider-min');
      const sMax = document.getElementById('gf-num-slider-max');

      // ensure meta.min/max are numbers and sensible
      const domainMin = (meta.min !== null && meta.min !== undefined && !Number.isNaN(Number(meta.min))) ? Number(meta.min) : 0;
      const domainMax = (meta.max !== null && meta.max !== undefined && !Number.isNaN(Number(meta.max))) ? Number(meta.max) : domainMin + 1;

      // set range attributes
      if (sMin && sMax) {
        sMin.min = domainMin; sMin.max = domainMax; sMin.step = '1';
        sMax.min = domainMin; sMax.max = domainMax; sMax.step = '1';
      }

      // helper to produce safe numeric values
      const safeNumber = (v, fallback) => {
        const n = Number(v);
        return Number.isNaN(n) ? fallback : n;
      };

      // initialize values with saved state or meta
      const initialMin = (s.min !== undefined && s.min !== null) ? Number(s.min) : domainMin;
      const initialMax = (s.max !== undefined && s.max !== null) ? Number(s.max) : domainMax;

      // clamp function
      const clamp = (v) => Math.max(domainMin, Math.min(domainMax, v));

      // Initialize using valueAsNumber for min/max inputs and string values for sliders
      if (minEl) minEl.valueAsNumber = clamp(initialMin);
      if (maxEl) maxEl.valueAsNumber = clamp(initialMax);
      if (sMin) sMin.value = String(clamp(initialMin));
      if (sMax) sMax.value = String(clamp(initialMax));

      // sync function: uses valueAsNumber, clamps, orders, writes back to both sliders and inputs
      const sync = () => {
        if (!minEl || !maxEl || !sMin || !sMax) return;
        
        // Read using valueAsNumber - handles NaN gracefully
        let a = Number.isNaN(minEl.valueAsNumber) ? domainMin : minEl.valueAsNumber;
        let b = Number.isNaN(maxEl.valueAsNumber) ? domainMax : maxEl.valueAsNumber;

        // ensure ordering
        if (a > b) [a, b] = [b, a];

        // clamp
        a = clamp(a); b = clamp(b);

        // persist to state
        s.min = a; s.max = b;

        // write back to all controls using valueAsNumber for inputs and strings for sliders
        minEl.valueAsNumber = a;
        maxEl.valueAsNumber = b;
        sMin.value = String(a);
        sMax.value = String(b);

        // Call live preview
        gf_renderSelectedChips(true);
        applyFiltersPipeline(true);
      };

      // wire text inputs with robust handling
      if (minEl) {
        minEl.oninput = sync;
        minEl.onblur = () => {
          // On blur, ensure value is never NaN
          if (Number.isNaN(minEl.valueAsNumber)) {
            minEl.valueAsNumber = domainMin;
          }
          sync();
        };
      }
      if (maxEl) {
        maxEl.oninput = sync;
        maxEl.onblur = () => {
          // On blur, ensure value is never NaN
          if (Number.isNaN(maxEl.valueAsNumber)) {
            maxEl.valueAsNumber = domainMax;
          }
          sync();
        };
      }

      // wire range sliders - update number inputs and call sync
      if (sMin) {
        sMin.oninput = (e) => {
          const v = safeNumber(e.target.value, domainMin);
          // if slider produced NaN ignore
          if (Number.isNaN(v)) return;
          const clampedV = clamp(v);
          if (minEl) minEl.valueAsNumber = clampedV;
          sync();
        };
      }
      if (sMax) {
        sMax.oninput = (e) => {
          const v = safeNumber(e.target.value, domainMax);
          if (Number.isNaN(v)) return;
          const clampedV = clamp(v);
          if (maxEl) maxEl.valueAsNumber = clampedV;
          sync();
        };
      }

      // bins UI - use consistent chip styling with colors
      const bins = document.getElementById('gf-num-bins');
      if (bins) bins.innerHTML = '';
      const binCount = meta.binCounts ? meta.binCounts.length : 0;
      for (let i = 0; i < binCount; i++) {
        const a = Math.round(domainMin + i * ((domainMax - domainMin) / Math.max(1, binCount)));
        const b = Math.round(i === binCount - 1 ? domainMax : domainMin + ((i + 1) * ((domainMax - domainMin) / Math.max(1, binCount))));
        const cnt = (meta.binCounts && meta.binCounts[i]) || 0;
        const chip = document.createElement('span');
        chip.className = 'gf-chip';
        chip.style.margin = '2px';
        
        // Apply consistent colors based on field name
        const h = hueFromString(col + i); // Use column name + bin index for consistent but varied colors
        const colors = chipColors(h);
        chip.style.setProperty('--chip-bg', colors.bg);
        chip.style.setProperty('--chip-fg', colors.fg);
        chip.style.setProperty('--chip-border', colors.border);
        chip.style.setProperty('--chip-bg-active', colors.bgActive);
        chip.style.setProperty('--chip-border-active', colors.borderActive);
        
        chip.textContent = `${a}–${b} `;
        const countEl = document.createElement('small');
        countEl.textContent = cnt.toLocaleString();
        chip.appendChild(countEl);
        
        chip.onclick = () => {
          if (minEl) minEl.valueAsNumber = a;
          if (maxEl) maxEl.valueAsNumber = b;
          sync();
        };
        bins.appendChild(chip);
      }

      // empty checkbox
      const empty = document.getElementById('gf-num-empty');
      if (empty) empty.innerHTML = '';
      if (meta.empties > 0 && empty) {
        const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = !!s.includeEmpty;
        chk.onchange = () => { s.includeEmpty = chk.checked; gf_renderSelectedChips(true); applyFiltersPipeline(true); };
        const lbl = document.createElement('label'); lbl.style.marginLeft = '6px'; lbl.textContent = `[EMPTY] ${meta.empties?.toLocaleString()}`;
        const wrapDiv = document.createElement('div'); wrapDiv.appendChild(chk); wrapDiv.appendChild(lbl);
        empty.appendChild(wrapDiv);
      }

    } else { // date
      const wrap = document.getElementById('gf-date-wrap');
      if (!wrap) return;
      wrap.style.display='block';
      const s = GF.state[col] || {type:'date', period:'quarter', buckets:new Set(), includeEmpty:false, start:null, end:null};
      GF.state[col] = s;

      const periodEl = document.getElementById('gf-date-period');
      const startEl  = document.getElementById('gf-date-start');
      const endEl    = document.getElementById('gf-date-end');
      if (periodEl) periodEl.value = s.period;
      if (periodEl) periodEl.onchange = ()=>{ s.period = periodEl.value; gf_showField(col); gf_renderSelectedChips(true); applyFiltersPipeline(true); };
      if (startEl) startEl.onchange = ()=>{ s.start = startEl.value||null; gf_renderSelectedChips(true); applyFiltersPipeline(true); };
      if (endEl) endEl.onchange   = ()=>{ s.end   = endEl.value||null; gf_renderSelectedChips(true); applyFiltersPipeline(true); };

      const bucketBox = document.getElementById('gf-date-buckets');
      if (bucketBox) bucketBox.innerHTML='';
      const all = [];
      if (s.period==='quarter') {
        // already precomputed: keys like "Q4 2020"
        
        for (const k in GF.meta?.[col]?.buckets || {}) if (k.startsWith('Q')) all.push([k, GF.meta?.[col]?.buckets?.[k]]);
        all.sort((a,b)=>a[0].localeCompare(b[0]));
      } else if (s.period==='year') {
        for (const k in GF.meta[col].buckets) if (/^\d{4}$/.test(k)) all.push([k, GF.meta[col].buckets[k]]);
        all.sort((a,b)=>a[0].localeCompare(b[0]));
      } else {        
        for (const k in GF.meta?.[col]?.buckets || {}) if (/^\d{4}-\d{2}$/.test(k)) all.push([k, GF.meta?.[col]?.buckets?.[k]]);
        all.sort((a,b)=>a[0].localeCompare(b[0]));
      }
      const onSet = s.buckets;
      all.forEach(([name,count])=>{
        const chip = document.createElement('button');
        chip.className = 'btn btn-sm ' + (onSet.has(name)?'btn-primary':'btn-outline-secondary');
        chip.style.margin='4px';
        chip.textContent = `${name}  ${count.toLocaleString()}`;
        chip.onclick = ()=>{ onSet.has(name)? onSet.delete(name) : onSet.add(name); gf_showField(col); gf_renderSelectedChips(true); applyFiltersPipeline(true); };
        if (bucketBox) bucketBox.appendChild(chip);
      });

      const empty = document.getElementById('gf-date-empty');
      if (empty) empty.innerHTML='';      
      if (GF.meta?.[col]?.empties>0 && empty){
        const chk = document.createElement('input'); chk.type='checkbox'; chk.checked=!!s.includeEmpty;
        chk.onchange = ()=>{ s.includeEmpty = chk.checked; gf_renderSelectedChips(true); applyFiltersPipeline(true); };        
        const lbl = document.createElement('label'); lbl.style.marginLeft='6px'; lbl.textContent = `[EMPTY] ${GF.meta?.[col]?.empties?.toLocaleString()}`;
        const wrapDiv = document.createElement('div'); wrapDiv.appendChild(chk); wrapDiv.appendChild(lbl);
        empty.appendChild(wrapDiv);
      }
    }
  }

  function applyGlobalFilters() {
    // Commit GF.state into app-level filters and force full redraw
    
    // If window.appFilters exists, use buildFiltersFromGFState to translate
    if (typeof window !== 'undefined' && typeof buildFiltersFromGFState === 'function') {
      window.appFilters = buildFiltersFromGFState(GF.state);
    } else {
      // Fallback: directly apply GF.state filtering
      filtered = rawData.filter(row=>{
        for (const [col, sel] of Object.entries(GF.state)) {
          const v0 = row[col];
          const empty = (v0===null || v0===undefined || String(v0).trim()==='');

          if (sel.type==='cat') {
            const hit = sel.include.has(String(v0));
            if (!hit && !(empty && sel.includeEmpty)) return false;
          }
          else if (sel.type==='num') {
            if (empty) { if (!sel.includeEmpty) return false; }
            else {
              const num = Number(v0);
              if (Number.isNaN(num) || num < sel.min || num > sel.max) return false;
            }
          }
          else if (sel.type==='date') {
            if (empty) { if (!sel.includeEmpty) return false; }
            else {
              const iso = new Date(v0).toISOString().slice(0,10);
              if (sel.start && iso < sel.start) return false;
              if (sel.end && iso > sel.end) return false;
              if (sel.buckets && sel.buckets.size){
                // accept values matching any selected bucket for the chosen period
                const y  = iso.slice(0,4);
                const ym = iso.slice(0,7);
                const q  = `Q${Math.floor((Number(iso.slice(5,7))-1)/3)+1} ${y}`;
                const key = sel.period==='quarter'? q : (sel.period==='year'? y : ym);
                if (!sel.buckets.has(key)) return false;
              }
            }
          }
        }
        return true;
      });
    }

    // Use the unified filter pipeline for Apply (non-live mode)
    applyFiltersPipeline(false);
    
    // Close the modal
    closeFiltersModal();
  }

  function gf_applyToDashboard() {
    // Legacy function - now just calls applyGlobalFilters for compatibility
    applyGlobalFilters();
  }

  // call once *after* rawData/columns are set
  function initGlobalFilters() {
    gf_buildMeta();
    gf_initUI();
  }

  // ----------------------------
  // Column detection
  // ----------------------------
  function detectColumns() {
    const nameHint = /(date|time|_dt|_time|timestamp)/i;
    const candidates = columns.filter(c => nameHint.test(c));
    const ranked = (candidates.length ? candidates : columns).map(c => {
      const score = scoreDateColumn(c);
      return { col: c, ...score };
    }).filter(s => s.valid);

    ranked.sort((a,b) => b.confidence - a.confidence);
    dateCol = ranked.length ? ranked[0].col : null;

    const ageCandidates = [
      'age_group','ageGroup','Age_Group',
      'age_group_22_1','age_group_22_2','age_group_23_1','age_group_23_2'
    ];
    ageCol = ageCandidates.find(c => columns.includes(c)) || null;

    const empCandidates = [
      'employment_type','employmentType','Employment_Type',
      'X20_21_kurzfragen_employment_type_clean','employment_type_clean',
      'X20_21_langfragen_employment_type_clean'
    ];
    empCol = empCandidates.find(c => columns.includes(c)) || null;

    numericCols = columns.filter(c => looksNumericColumn(c));
    categoricalCols = columns.filter(c => looksCategoricalColumn(c));
  }

  function scoreDateColumn(col) {
    const vals = sampleValues(col, 300);
    let parsed = 0, withinRange = 0;
    for (const v of vals) {
      const d = new Date(v);
      if (!isNaN(d)) {
        parsed++;
        const y = d.getUTCFullYear();
        if (y >= 2019 && y <= 2024) withinRange++;
      }
    }
    const rate = vals.length ? parsed / vals.length : 0;
    const rangeRate = vals.length ? withinRange / vals.length : 0;
    const valid = rate >= 0.7 && rangeRate >= 0.7;
    const confidence = (rate + rangeRate) / 2 + (/(date|time|timestamp)/i.test(col) ? 0.1 : 0);
    return { valid, confidence };
  }

  function sampleValues(col, n=200) {
    const arr = [];
    const step = Math.max(1, Math.floor(rawData.length / n));
    for (let i=0; i<rawData.length; i+=step) {
      const v = rawData[i]?.[col];
      if (v !== undefined && v !== null && v !== '') arr.push(v);
      if (arr.length >= n) break;
    }
    return arr;
  }

  // ----------------------------
  // Populate filters & builder
  // ----------------------------
  function populateFilters() {
    const container = id('filter-container');
    if (!container) return;
    
    container.innerHTML = '';

    categoricalCols.forEach(col => {
      const values = uniqueNonEmpty(rawData.map(r => r[col]));
      if (values.length > 50) return;
      const wrapper = document.createElement('div');
      wrapper.className = 'mb-3';
      const label = document.createElement('label');
      label.className = 'form-label';
      label.textContent = col;
      wrapper.appendChild(label);
      const row = document.createElement('div');
      row.className = 'filter-row';
      const select = document.createElement('select');
      select.className = 'form-select';
      select.multiple = true;
      select.size = Math.min(values.length, 6);
      select.dataset.col = col;
      values.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        opt.selected = true;
        select.appendChild(opt);
      });
      const actions = document.createElement('div');
      actions.className = 'filter-actions';
      const btnSel = document.createElement('button');
      btnSel.className = 'btn btn-outline-secondary btn-sm';
      btnSel.textContent = 'Select all';
      btnSel.addEventListener('click', () => {
        for (const o of select.options) o.selected = true;
        select.dispatchEvent(new Event('change'));
      });
      const btnClr = document.createElement('button');
      btnClr.className = 'btn btn-outline-secondary btn-sm';
      btnClr.textContent = 'Clear';
      btnClr.addEventListener('click', () => {
        for (const o of select.options) o.selected = false;
        select.dispatchEvent(new Event('change'));
      });
      actions.appendChild(btnSel);
      actions.appendChild(btnClr);
      row.appendChild(select);
      row.appendChild(actions);
      wrapper.appendChild(row);
      container.appendChild(wrapper);
      select.addEventListener('change', applyFilters);
    });

    if (dateCol) {
      const startDateEl = id('startDate');
      const endDateEl = id('endDate');
      
      if (startDateEl && endDateEl) {
        const dates = rawData
          .map(r => parseValidDate(r[dateCol]))
          .filter(Boolean)
          .sort((a,b) => a - b);

        if (dates.length) {
          const minISO = toISO(dates[0]);
          const maxISO = toISO(dates[dates.length-1]);
          startDateEl.min = minISO;
          startDateEl.max = maxISO;
          endDateEl.min   = minISO;
          endDateEl.max   = maxISO;
          startDateEl.dataset.col = dateCol;
          endDateEl.dataset.col   = dateCol;
          // Remove default values to avoid activating date filter on initial load
          // startDateEl.value = minISO;
          // endDateEl.value   = maxISO;
        }
      }
    }
  }

  function populateBuilderSelects() {
    const xSel = id('fldX'), ySel = id('fldY'), cSel = id('fldColor');
    const y2Sel = id('fldY2'), yCatSel = id('fldYCat'), sizeSel = id('fldSize');

    // Clear all selects
    [xSel, ySel, y2Sel, yCatSel, sizeSel, cSel].forEach(s => {
      if (s) s.innerHTML = '';
    });

    // Helper function to populate select with optgroups
    function populateSelectWithOptgroups(select, includeEmpty = true) {
      if (!select) return;
      
      if (includeEmpty) {
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = '';
        select.appendChild(emptyOption);
      }
      
      // Group columns by type
      const categoricalCols = [];
      const numericCols = [];
      const dateCols = [];
      const otherCols = [];
      
      columns.forEach(col => {
        const type = getColumnType(col);
        switch (type) {
          case 'categorical': categoricalCols.push(col); break;
          case 'numeric': numericCols.push(col); break;
          case 'date': dateCols.push(col); break;
          default: otherCols.push(col); break;
        }
      });
      
      // Add optgroups
      if (categoricalCols.length > 0) {
        const catGroup = document.createElement('optgroup');
        catGroup.label = 'Categorical';
        categoricalCols.forEach(col => {
          const opt = document.createElement('option');
          opt.value = col;
          opt.textContent = col;
          catGroup.appendChild(opt);
        });
        select.appendChild(catGroup);
      }
      
      if (numericCols.length > 0) {
        const numGroup = document.createElement('optgroup');
        numGroup.label = 'Numeric';
        numericCols.forEach(col => {
          const opt = document.createElement('option');
          opt.value = col;
          opt.textContent = col;
          numGroup.appendChild(opt);
        });
        select.appendChild(numGroup);
      }
      
      if (dateCols.length > 0) {
        const dateGroup = document.createElement('optgroup');
        dateGroup.label = 'Date/Time';
        dateCols.forEach(col => {
          const opt = document.createElement('option');
          opt.value = col;
          opt.textContent = col;
          dateGroup.appendChild(opt);
        });
        select.appendChild(dateGroup);
      }
      
      if (otherCols.length > 0) {
        const otherGroup = document.createElement('optgroup');
        otherGroup.label = 'Other';
        otherCols.forEach(col => {
          const opt = document.createElement('option');
          opt.value = col;
          opt.textContent = col;
          otherGroup.appendChild(opt);
        });
        select.appendChild(otherGroup);
      }
    }
    
    // Populate all selects with optgroups
    populateSelectWithOptgroups(xSel, true);
    populateSelectWithOptgroups(ySel, true);
    populateSelectWithOptgroups(cSel, true);
    populateSelectWithOptgroups(y2Sel, true);
    populateSelectWithOptgroups(yCatSel, true);
    populateSelectWithOptgroups(sizeSel, true);

    updateBuilderVisibility();
    updateTransformationSummary();
  }

  function updateTransformationSummary() {
    const summaryEl = id('transformationSummary');
    if (!summaryEl) return;
    
    const type = id('fldType')?.value;
    const xField = id('fldX')?.value;
    const yField = id('fldY')?.value;
    const colorField = id('fldColor')?.value;
    
    if (!type || !xField) {
      summaryEl.textContent = 'Select chart type and X field to see transformation details.';
      return;
    }
    
    const xType = getColumnType(xField);
    const yType = yField ? getColumnType(yField) : null;
    const colorType = colorField ? getColumnType(colorField) : null;
    
    let summary = [];
    
    // X transformations
    if (type === 'histogram') {
      if (xField === 'dose_interval_days') {
        summary.push('X → dose interval preset (clip [0,200], 50 bins, rangeslider)');
      } else if (xType === 'numeric') {
        const bins = id('fldXBins')?.value || '30';
        summary.push(`X → numeric binned (${bins} bins)`);
      } else if (xType === 'date') {
        const period = id('fldXPeriod')?.value || 'month';
        summary.push(`X → date grouped by ${period}`);
      } else {
        summary.push('X → categorical bins (count per category)');
      }
    } else if (type === 'bar') {
      if (xType === 'categorical') {
        summary.push('X → categorical axis');
      } else if (xType === 'numeric') {
        const bins = id('fldXBins')?.value || '30';
        summary.push(`X → numeric auto-binned (${bins} bins)`);
      } else if (xType === 'date') {
        const period = id('fldXPeriod')?.value || 'month';
        summary.push(`X → date binned by ${period}`);
      }
    } else if (['line', 'timeseries'].includes(type)) {
      if (xType === 'date' || xType === 'numeric') {
        summary.push('X → sorted axis');
      } else {
        const order = id('fldXOrder')?.value || 'alphabetical';
        summary.push(`X → categorical (${order} order)`);
        if (id('chkEncodeCategorical')?.checked) {
          summary.push('categorical encoded to ordinal');
        }
      }
    } else if (['scatter', 'bubble'].includes(type)) {
      if (xType === 'categorical') {
        summary.push('X → categorical');
        if (id('chkEncodeCategorical')?.checked) {
          summary.push('encoded to ordinal');
        }
        if (id('chkAddJitter')?.checked) {
          summary.push('with jitter');
        }
      } else {
        summary.push(`X → ${xType} axis`);
      }
    } else {
      summary.push(`X → ${xType}`);
    }
    
    // Y transformations
    if (yField && !['histogram'].includes(type)) {
      if (yType === 'categorical' && type === 'box') {
        summary.push('Y → non-numeric (converted to frequency bars)');
      } else {
        const agg = id('fldAgg')?.value || 'count';
        if (agg === 'count' && !yField) {
          summary.push('Y → count');
        } else {
          summary.push(`Y → ${agg}(${yField})`);
        }
      }
    }
    
    // Color transformations
    if (colorField) {
      if (colorType === 'categorical') {
        summary.push(`Color → split series by ${colorField}`);
      } else if (colorType === 'numeric' && ['scatter', 'bubble'].includes(type)) {
        summary.push(`Color → continuous scale (${colorField})`);
      } else if (colorType === 'numeric') {
        summary.push(`Color → quantile groups (${colorField})`);
      }
    }
    
    summaryEl.textContent = summary.length > 0 ? summary.join(', ') : 'No transformations applied.';
  }

  function updateAdvancedVisibility() {
    const type = id('fldType')?.value;
    const xField = id('fldX')?.value;
    const xType = xField ? getColumnType(xField) : null;
    
    // Show/hide advanced controls based on field selections
    const xBinning = id('advancedXBinning');
    const xPeriod = id('advancedXPeriod');
    const xOrder = id('advancedXOrder');
    const histogram = id('advancedHistogram');
    
    if (xBinning) {
      xBinning.style.display = (xType === 'numeric') ? 'block' : 'none';
      // Set default nbins for dose preset
      if (xField === 'dose_interval_days') {
        const binsEl = id('fldXBins');
        if (binsEl) binsEl.value = '50';
      }
    }
    
    if (xPeriod) {
      xPeriod.style.display = (xType === 'date') ? 'block' : 'none';
    }
    
    if (xOrder) {
      xOrder.style.display = (xType === 'categorical') ? 'block' : 'none';
    }
    
    if (histogram) {
      histogram.style.display = (type === 'histogram') ? 'block' : 'none';
      // Set default rangeslider for dose preset
      if (type === 'histogram' && xField === 'dose_interval_days') {
        const rangesliderEl = id('chkShowRangeslider');
        if (rangesliderEl) rangesliderEl.checked = true;
      }
    }
  }

  // ----------------------------
  // Filtering + table
  // ----------------------------
  function applyFilters() {
    // Read UI values into Simple state
    const startDateEl = id('startDate');
    const endDateEl = id('endDate');
    const filterContainer = id('filter-container');
    
    // Update Simple date range
    Simple.dateRange.start = startDateEl?.value ? new Date(startDateEl.value) : null;
    Simple.dateRange.end = endDateEl?.value ? new Date(endDateEl.value) : null;

    // Update Simple category filters
    Simple.categoryFilters = {};
    if (filterContainer) {
      const filterSelects = filterContainer.querySelectorAll('select[data-col]');
      filterSelects.forEach(sel => {
        const col = sel.dataset.col;
        const selected = Array.from(sel.selectedOptions).map(o => String(o.value));
        const totalOptions = sel.options.length;
        // Only create filter if some (but not all) options are selected
        // This treats "all selected" as "no filter" to avoid excluding rows with empty values
        if (selected && selected.length > 0 && selected.length < totalOptions) {
          Simple.categoryFilters[col] = selected;
        }
      });
    }

    // Use unified filter pipeline
    applyFiltersPipeline(false);
  }
  function updateTable() {
    const wrap = id('tableWrap');
    if (!wrap) return;
  
    // Use the PreviewRenderer for paginated rendering (15 rows per "page")
    if (typeof PreviewRenderer !== 'undefined' && PreviewRenderer.renderRows) {
      PreviewRenderer.rowsPerPage = 15; // ensure the page size is 15
      PreviewRenderer.renderRows(filteredRows || []);
      return;
    }
  
    // Fallback (shouldn't be hit): simple empty state
    wrap.innerHTML = (!filteredRows || !filteredRows.length)
      ? '<div class="text-muted">No data to display</div>'
      : '';
  }    
        
  // ----------------------------
  // Starter charts
  // ----------------------------
  function autoStarterCharts() {
    const numCols = numericCols;
    const catCols = categoricalCols;

    const income = ['X20_21_langfragen_income','income'].find(c => columns.includes(c)) || (numCols.length ? numCols[0] : null);
    const age = catCols.find(c => /age/i.test(c)) || (catCols.length ? catCols[0] : null);
    const emp = catCols.find(c => /employ|job|work/i.test(c)) || (catCols.length > 1 ? catCols[1] : null);

    if (emp) addChart({ type: 'pie', x: emp, y: income || emp, agg: 'count' });
    if (age && income) addChart({ type: 'bar', x: age, y: income, agg: 'mean' });
    if (dateCol && income) addChart({ type: 'line', x: dateCol, y: income, agg: 'mean' });
  }

  function looksNumericColumn(col) {
    const vals = sampleValues(col, 200);
    if (!vals.length) return false;
    let nums = 0;
    for (const v of vals) if (typeof v === 'number' && !Number.isNaN(v)) nums++;
    return nums / vals.length >= 0.7;
  }

  function looksCategoricalColumn(col) {
    const vals = sampleValues(col, 400);
    const uniq = new Set(vals.filter(v => v !== '' && v !== null && v !== undefined).map(String));
    const mostlyNums = looksNumericColumn(col);
    return !mostlyNums && uniq.size >= 2 && uniq.size <= 20;
  }

  function makePivotMatrix(rows, rowKey, colKey, valKey, aggName='count') {
    const rset = new Set(), cset = new Set();
    const map = new Map(); // key = r¦c -> array of rows
    rows.forEach(r => {
      const rk = String(r[rowKey]);
      const ck = String(r[colKey]);
      rset.add(rk); cset.add(ck);
      const key = rk + '¦' + ck;
      if (!map.has(key)) map.set(key, []);
      map.get(key).push(r);
    });
    const rArr = Array.from(rset), cArr = Array.from(cset);
    const aggCell = (arr) => {
      if (aggName === 'count') return arr.length;
      const vs = arr.map(x => +x[valKey]).filter(v => !Number.isNaN(v));
      if (!vs.length) return 0;
      if (aggName === 'sum')  return vs.reduce((a,b)=>a+b,0);
      return vs.reduce((a,b)=>a+b,0)/vs.length;
    };
    const z = rArr.map(rk => cArr.map(ck => aggCell(map.get(rk+'¦'+ck) || [])));
    // Build HTML table too (for pivot card)
    const table = document.createElement('table');
    table.className = 'table table-sm table-bordered';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    trh.appendChild(Object.assign(document.createElement('th'), {textContent: rowKey + ' \\ ' + colKey}));
    cArr.forEach(c => trh.appendChild(Object.assign(document.createElement('th'), {textContent: c})));
    thead.appendChild(trh);
    const tbody = document.createElement('tbody');
    rArr.forEach((rk, i) => {
      const tr = document.createElement('tr');
      tr.appendChild(Object.assign(document.createElement('td'), {textContent: rk}));
      z[i].forEach(v => tr.appendChild(Object.assign(document.createElement('td'), {textContent: v})));
      tbody.appendChild(tr);
    });
    table.appendChild(thead); table.appendChild(tbody);
    return { rows: rArr, cols: cArr, z, html: table.outerHTML };
  }

  // ----------------------------
  // Draggable Chart Cards
  // ----------------------------
  function makeDraggable(card) {
    const header = card.querySelector('.card-header');
    if (!header) return;

    let isDragging = false;
    let startX, startY, initialX, initialY;

    header.addEventListener('mousedown', initDrag);
    
    function initDrag(e) {
      // Don't start drag if clicking on remove button
      if (e.target.closest('.remove')) return;
      
      isDragging = true;
      card.classList.add('dragging');
      
      // Get initial mouse position
      startX = e.clientX;
      startY = e.clientY;
      
      // Get initial card position
      const rect = card.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;
      
      // Convert card to fixed positioning for smooth dragging
      card.style.position = 'fixed';
      card.style.left = initialX + 'px';
      card.style.top = initialY + 'px';
      card.style.margin = '0';
      card.style.zIndex = '1000';
      
      // Add global event listeners
      document.addEventListener('mousemove', doDrag);
      document.addEventListener('mouseup', stopDrag);
      
      // Prevent text selection
      document.body.style.userSelect = 'none';
      
      e.preventDefault();
    }
    
    function doDrag(e) {
      if (!isDragging) return;
      
      // Calculate new position
      const currentX = initialX + (e.clientX - startX);
      const currentY = initialY + (e.clientY - startY);
      
      // Update card position
      card.style.left = currentX + 'px';
      card.style.top = currentY + 'px';
    }
    
    function stopDrag(e) {
      if (!isDragging) return;
      
      isDragging = false;
      card.classList.remove('dragging');
      
      // Reset positioning to relative within grid
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';
      card.style.margin = '';
      card.style.zIndex = '';
      
      // Calculate drop position within grid
      const gridRect = id('grid').getBoundingClientRect();
      const cardRect = card.getBoundingClientRect();
      
      // Only reorder if dropped within grid bounds
      if (cardRect.left >= gridRect.left && 
          cardRect.top >= gridRect.top && 
          cardRect.right <= gridRect.right && 
          cardRect.bottom <= gridRect.bottom) {
        
        // Find the best insertion point
        const grid = id('grid');
        const allCards = Array.from(grid.querySelectorAll('.card-chart'));
        const draggedCard = card;
        
        let insertBeforeCard = null;
        let minDistance = Infinity;
        
        allCards.forEach(otherCard => {
          if (otherCard === draggedCard) return;
          
          const otherRect = otherCard.getBoundingClientRect();
          const distance = Math.abs(cardRect.left - otherRect.left) + 
                          Math.abs(cardRect.top - otherRect.top);
          
          if (distance < minDistance && 
              (cardRect.left < otherRect.left || 
               (Math.abs(cardRect.left - otherRect.left) < 100 && cardRect.top < otherRect.top))) {
            minDistance = distance;
            insertBeforeCard = otherCard;
          }
        });
        
        // Reorder in DOM
        if (insertBeforeCard) {
          grid.insertBefore(draggedCard, insertBeforeCard);
        } else {
          grid.appendChild(draggedCard);
        }
      }
      
      // Clean up
      document.removeEventListener('mousemove', doDrag);
      document.removeEventListener('mouseup', stopDrag);
      document.body.style.userSelect = '';
    }
  }

  // Initialize dragging for existing chart cards
  function initExistingCardsDraggable() {
    const existingCards = document.querySelectorAll('.card-chart');
    existingCards.forEach(card => makeDraggable(card));
  }

  // ----------------------------
  // Charting
  // ----------------------------
  function addChart(cfg) {
    charts.push(cfg);
    const card = document.createElement('div');
    card.className = 'card-chart';
    card.innerHTML = `
      <div class="card-header">
        <h6>${titleFor(cfg)}</h6>
        <button class="remove" title="Remove"><i class="bi bi-x-lg"></i></button>
      </div>
      <div class="plot"></div>
      <div class="resizable-corner"></div>
    `;
    id('grid').appendChild(card);
    cfg._el = card.querySelector('.plot');
    cfg._card = card;
    card.querySelector('.remove').addEventListener('click', () => {
      charts = charts.filter(c => c !== cfg);
      card.remove();
    });
    drawChart(cfg);
    
    // Make the card draggable
    makeDraggable(card);
    
    // Attach edit FAB
    attachEditFab(card, cfg);
    
    // Ensure ResizeObserver is watching this plot element
    if (window.plotlyResizeObserver && cfg._el) {
      window.plotlyResizeObserver.observe(cfg._el);
    }
  }

  function titleFor(cfg) {
    const t = cfg.type[0].toUpperCase() + cfg.type.slice(1);
    const parts = [`${t}`];
    if (cfg.x) parts.push(`X: ${cfg.x}`);
    if (cfg.y && cfg.agg) parts.push(`Y: ${cfg.agg}(${cfg.y})`);
    if (cfg.color) parts.push(`Color: ${cfg.color}`);
    return parts.join(' · ');
  }

  function drawChart(cfg) {
    const el = cfg._el;
    
    // Handle datatable and pivot separately (no change)
    if (cfg.type === 'datatable') {
      el.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'table-responsive';
      el.appendChild(wrap);
      const table = document.createElement('table');
      table.className = 'table table-sm table-striped';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      columns.forEach(c => { const th = document.createElement('th'); th.textContent = c; trh.appendChild(th); });
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      (filteredRows.slice(0,200)).forEach(r => {
        const tr = document.createElement('tr');
        columns.forEach(c => {
          const td = document.createElement('td'); td.textContent = (r[c] ?? ''); tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(thead); table.appendChild(tbody);
      wrap.appendChild(table);
      return;
    }

    if (cfg.type === 'pivot') {
      const matrix = makePivotMatrix(filteredRows, cfg.x, cfg.yCat, cfg.y, cfg.agg);
      el.innerHTML = matrix.html;
      return;
    }

    if (!filteredRows.length) { el.innerHTML = '<div class="text-muted p-2">No data</div>'; return; }

    // Get data for the chart
    const data = filteredRows;
    
    // Initialize Plotly figure
    let fig = { 
      data: [], 
      layout: { 
        margin: {l:50,r:20,b:50,t:40}, 
        title: titleFor(cfg)
      } 
    };

    // Type-agnostic rendering
    if (cfg.type === 'histogram') {
      drawHistogram(cfg, data, fig);
    } else if (cfg.type === 'bar') {
      drawBar(cfg, data, fig);  
    } else if (cfg.type === 'line' || cfg.type === 'timeseries') {
      drawLine(cfg, data, fig);
    } else if (cfg.type === 'scatter' || cfg.type === 'bubble') {
      drawScatter(cfg, data, fig);
    } else if (cfg.type === 'pie') {
      drawPie(cfg, data, fig);
    } else if (cfg.type === 'box') {
      drawBox(cfg, data, fig);
    } else if (cfg.type === 'barline') {
      drawBarLine(cfg, data, fig);
    } else if (cfg.type === 'heatmap') {
      drawHeatmap(cfg, data, fig);
    } else if (cfg.type === 'funnel') {
      drawFunnel(cfg, data, fig);
    }

    Plotly.newPlot(el, fig.data, fig.layout, { responsive: true });
  }

  function drawHistogram(cfg, data, fig) {
    if (!cfg.x) return;
    
    const xField = cfg.x;
    const xType = getColumnType(xField);
    
    if (xType === 'numeric') {
      // Build numeric values: first filter out null/undefined/empty, then convert to numbers and filter finite values
      // This prevents null/''/undefined from being coerced to 0 which would create a spike at zero
      const numericVals = data
        .map(r => r[xField])
        .filter(v => v != null && v !== '')  // Remove null, undefined, empty string first
        .map(v => Number(v))                 // Convert to number
        .filter(v => Number.isFinite(v));    // Keep only finite numbers (excludes NaN, Infinity)
      
      // Console diagnostic for debugging (can be enabled via flag)
      const debugHistogram = false; // Set to true for debugging
      if (debugHistogram) {
        const totalRows = data.length;
        const excludedCount = totalRows - numericVals.length;
        console.log(`Histogram ${xField}: excluded ${excludedCount} invalid values out of ${totalRows} total`);
      }
      
      // Special handling for dose_interval_days preset
      if (xField === 'dose_interval_days') {
        // Filter valid range [0, 200] for plotting only; out-of-range values excluded
        const clippedVals = numericVals.filter(v => v >= 0 && v <= 200);
        fig.data.push({
          x: clippedVals,
          type: 'histogram',
          nbinsx: cfg.xBins || 50,
          name: 'Count'
        });
        
        // Add rangeslider with thickness and set initial zoom [0,100]
        if (cfg.showRangeslider) {
          fig.layout.xaxis = { 
            title: xField,
            rangeslider: { visible: true, thickness: 0.02 },
            range: [0, 100]  // Initial zoom to [0,100]
          };
        } else {
          fig.layout.xaxis = { title: xField };
        }
      } else {
        // Regular numeric histogram - use filtered numeric values, never coerce invalids to 0
        fig.data.push({
          x: numericVals,
          type: 'histogram', 
          nbinsx: cfg.xBins || 30,
          name: 'Count'
        });
        
        fig.layout.xaxis = { title: xField };
        if (cfg.showRangeslider) {
          fig.layout.xaxis.rangeslider = { visible: true };
        }
      }
    } else if (xType === 'date') {
      // Date histogram - group by period and render as bars
      const xVals = data.map(r => r[xField]).filter(v => v != null && v !== '');
      const period = cfg.xPeriod || 'month';
      const { labels, counts } = binDates(xVals, period);
      
      fig.data.push({
        x: labels,
        y: counts,
        type: 'bar',
        name: 'Count'
      });
      
      fig.layout.xaxis = { title: `${xField} (${period})` };
    } else {
      // Categorical histogram - count per category  
      const xVals = data.map(r => r[xField]).filter(v => v != null && v !== '');
      const groups = {};
      xVals.forEach(v => {
        const key = String(v);
        groups[key] = (groups[key] || 0) + 1;
      });
      
      // Apply ordering
      let sortedKeys = Object.keys(groups);
      if (cfg.xOrder === 'frequency_desc') {
        sortedKeys.sort((a, b) => groups[b] - groups[a]);
      } else if (cfg.xOrder === 'frequency_asc') {
        sortedKeys.sort((a, b) => groups[a] - groups[b]);
      } else {
        sortedKeys.sort();
      }
      
      fig.data.push({
        x: sortedKeys,
        y: sortedKeys.map(k => groups[k]),
        type: 'bar',
        name: 'Count'
      });
      
      fig.layout.xaxis = { title: xField };
    }
    
    fig.layout.yaxis = { title: 'Count' };
  }

  function drawBar(cfg, data, fig) {
    if (!cfg.x) return;
    
    const xField = cfg.x;
    const xType = getColumnType(xField);
    const colorField = cfg.color;
    const colorType = colorField ? getColumnType(colorField) : null;
    
    // Group data by X and optionally by color
    const groupBy = (rows, keys) => {
      const map = new Map();
      for (const r of rows) {
        const key = keys.map(k => String(r[k] || '')).join('¦');
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(r);
      }
      return { map, keys };
    };
    
    const agg = (rows) => {
      if (cfg.agg === 'count') return rows.length;
      if (!cfg.y) return rows.length;
      const vals = rows.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
      if (!vals.length) return 0;
      if (cfg.agg === 'sum') return vals.reduce((a,b)=>a+b,0);
      return vals.reduce((a,b)=>a+b,0) / vals.length; // mean
    };
    
    if (xType === 'categorical') {
      // Standard categorical bars
      const by = colorField ? [xField, colorField] : [xField];
      const g = groupBy(data, by);
      const xs = new Set(), colors = new Set();
      
      for (const k of g.map.keys()) {
        const parts = k.split('¦'); 
        xs.add(parts[0]); 
        if (colorField) colors.add(parts[1] || '(empty)');
      }
      
      const xArr = Array.from(xs);
      const colorArr = colorField ? Array.from(colors) : [null];
      
      // Apply categorical ordering
      if (cfg.xOrder === 'frequency_desc' || cfg.xOrder === 'frequency_asc') {
        const counts = {};
        xArr.forEach(x => {
          const rows = Array.from(g.map.entries())
            .filter(([k]) => k.split('¦')[0] === x)
            .flatMap(([,rows]) => rows);
          counts[x] = rows.length;
        });
        xArr.sort((a, b) => cfg.xOrder === 'frequency_desc' ? 
          counts[b] - counts[a] : counts[a] - counts[b]);
      } else {
        xArr.sort();
      }
      
      for (const cval of colorArr) {
        const y = xArr.map(xv => {
          const actualCval = cval === '(empty)' ? '' : cval;
          const key = colorField ? [xv, actualCval].join('¦') : String(xv);
          return agg(g.map.get(key) || []);
        });
        fig.data.push({ x: xArr, y, type: 'bar', name: cval ?? 'value' });
      }
      
      fig.layout.barmode = colorField ? 'group' : 'stack';
      fig.layout.xaxis = { title: xField };
      
    } else if (xType === 'numeric' || xType === 'date') {
      // Auto-bin numeric/date X, then aggregate Y within bins
      let binData;
      if (xType === 'numeric') {
        const xVals = data.map(r => r[xField]).filter(v => typeof v === 'number' && !isNaN(v));
        binData = binNumeric(xVals, cfg.xBins || 30);
      } else {
        const xVals = data.map(r => r[xField]).filter(v => v != null);
        binData = binDates(xVals, cfg.xPeriod || 'month');
      }
      
      if (colorField && colorType === 'categorical') {
        // Split by color categories
        const colorVals = [...new Set(data.map(r => r[colorField] || '(empty)'))];
        
        for (const colorVal of colorVals) {
          const colorRows = data.filter(r => (r[colorField] || '(empty)') === colorVal);
          
          let y;
          if (xType === 'numeric') {
            y = binData.bins.map(binCenter => {
              const binMin = binCenter - binData.binWidth / 2;
              const binMax = binCenter + binData.binWidth / 2;
              const binRows = colorRows.filter(r => {
                const xVal = r[xField];
                return typeof xVal === 'number' && !isNaN(xVal) && xVal >= binMin && xVal < binMax;
              });
              return agg(binRows);
            });
          } else {
            y = binData.labels.map(label => {
              const binRows = colorRows.filter(r => {
                const period = cfg.xPeriod || 'month';
                const d = new Date(r[xField]);
                if (isNaN(d)) return false;
                
                let key;
                const year = d.getUTCFullYear();
                const month = String(d.getUTCMonth() + 1).padStart(2, '0');
                
                switch (period) {
                  case 'day': key = d.toISOString().slice(0, 10); break;
                  case 'month': key = `${year}-${month}`; break;
                  case 'quarter': 
                    const quarter = Math.floor((d.getUTCMonth() + 3) / 3);
                    key = `Q${quarter} ${year}`; break;
                  case 'year': key = String(year); break;
                  default: key = `${year}-${month}`;
                }
                return key === label;
              });
              return agg(binRows);
            });
          }
          
          fig.data.push({ 
            x: xType === 'numeric' ? binData.bins : binData.labels, 
            y, 
            type: 'bar', 
            name: colorVal === '(empty)' ? '(empty)' : colorVal 
          });
        }
        fig.layout.barmode = 'group';
      } else {
        // Single series
        fig.data.push({ 
          x: xType === 'numeric' ? binData.bins : binData.labels, 
          y: xType === 'numeric' ? binData.counts : binData.counts, 
          type: 'bar', 
          name: 'value' 
        });
      }
      
      const xTitle = xType === 'numeric' ? 
        `${xField} (${cfg.xBins || 30} bins)` : 
        `${xField} (${cfg.xPeriod || 'month'})`;
      fig.layout.xaxis = { title: xTitle };
    }
    
    if (cfg.y) fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };
    else fig.layout.yaxis = { title: 'Count' };
  }

  function drawLine(cfg, data, fig) {
    if (!cfg.x) return;
    
    const xField = cfg.x;
    const xType = getColumnType(xField);
    const colorField = cfg.color;
    const colorType = colorField ? getColumnType(colorField) : null;
    
    // Group by X and optionally color
    const groupBy = (rows, keys) => {
      const map = new Map();
      for (const r of rows) {
        const key = keys.map(k => String(r[k] || '')).join('¦');
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(r);
      }
      return { map, keys };
    };
    
    const agg = (rows) => {
      if (cfg.agg === 'count') return rows.length;
      if (!cfg.y) return rows.length;
      const vals = rows.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
      if (!vals.length) return 0;
      if (cfg.agg === 'sum') return vals.reduce((a,b)=>a+b,0);
      return vals.reduce((a,b)=>a+b,0) / vals.length;
    };
    
    if (colorField && colorType === 'categorical') {
      // Multiple lines per color category
      const g = groupBy(data, [xField, colorField]);
      const xVals = new Set();
      const colorVals = new Set();
      
      for (const k of g.map.keys()) {
        const parts = k.split('¦');
        xVals.add(parts[0]);
        colorVals.add(parts[1] || '(empty)');
      }
      
      const sortedXVals = Array.from(xVals).sort((a,b) => {
        if (xType === 'date') {
          const da = new Date(a), db = new Date(b);
          if (!isNaN(da) && !isNaN(db)) return da - db;
        }
        if (xType === 'numeric') {
          const na = +a, nb = +b;
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
        }
        return String(a).localeCompare(String(b));
      });
      
      for (const colorVal of colorVals) {
        let xData = sortedXVals;
        let yData = sortedXVals.map(xv => {
          const key = [xv, colorVal === '(empty)' ? '' : colorVal].join('¦');
          return agg(g.map.get(key) || []);
        });
        
        // Handle categorical X with encoding
        if (xType === 'categorical' && cfg.encodeCategorical) {
          const encoded = encodeCategorical(xData);
          xData = encoded.values;
          if (cfg.addJitter) {
            xData = jitter(xData);
          }
        }
        
        const traceName = colorVal === '(empty)' ? '(empty)' : colorVal;
        fig.data.push({ 
          x: xData, 
          y: yData, 
          type: 'scatter', 
          mode: 'lines+markers', 
          name: traceName 
        });
      }
      
    } else {
      // Single line
      const g = groupBy(data, [xField]);
      let xVals = Array.from(g.map.keys()).map(k => k.split('¦')[0]);
      
      // Sort appropriately
      xVals.sort((a,b) => {
        if (xType === 'date') {
          const da = new Date(a), db = new Date(b);
          if (!isNaN(da) && !isNaN(db)) return da - db;
        }
        if (xType === 'numeric') {
          const na = +a, nb = +b;
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
        }
        // Categorical ordering
        if (xType === 'categorical') {
          if (cfg.xOrder === 'frequency_desc' || cfg.xOrder === 'frequency_asc') {
            const counts = {};
            xVals.forEach(x => counts[x] = (g.map.get(x) || []).length);
            return cfg.xOrder === 'frequency_desc' ? counts[b] - counts[a] : counts[a] - counts[b];
          }
        }
        return String(a).localeCompare(String(b));
      });
      
      let yVals = xVals.map(xv => agg(g.map.get(String(xv)) || g.map.get(xv) || []));
      let xData = xVals;
      
      // Handle categorical X encoding
      if (xType === 'categorical' && cfg.encodeCategorical) {
        const encoded = encodeCategorical(xData);
        xData = encoded.values;
        if (cfg.addJitter) {
          xData = jitter(xData);
        }
        // Store tick info for axis
        fig.layout.xaxis = { 
          title: xField,
          tickvals: encoded.ticks.map(t => t.value),
          ticktext: encoded.ticks.map(t => t.label)
        };
      } else {
        fig.layout.xaxis = { title: xField };
      }
      
      fig.data.push({ x: xData, y: yVals, type: 'scatter', mode: 'lines+markers', name: cfg.y || 'count' });
    }
    
    if (cfg.histOverlay) {
      const vals = data.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
      fig.data.push({ x: vals, type: 'histogram', opacity: 0.35, xaxis: 'x2', yaxis: 'y2', name: 'Histogram' });
      fig.layout.grid = { rows: 1, columns: 2, pattern: 'independent' };
      fig.layout.xaxis2 = {};
      fig.layout.yaxis2 = {};
      fig.layout.title += ' · + Histogram';
    }
    
    if (!fig.layout.xaxis) fig.layout.xaxis = { title: xField };
    if (cfg.y) fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };
    else fig.layout.yaxis = { title: 'Count' };
  }

  function drawScatter(cfg, data, fig) {
    if (!cfg.x || !cfg.y) return;
    
    const xField = cfg.x;
    const yField = cfg.y;
    const xType = getColumnType(xField);
    const yType = getColumnType(yField);
    const colorField = cfg.color;
    const colorType = colorField ? getColumnType(colorField) : null;
    
    if (colorField && colorType === 'categorical') {
      // Split into multiple traces by category
      const colorVals = [...new Set(data.map(r => r[colorField] || '(empty)'))];
      
      for (const colorVal of colorVals) {
        const colorRows = data.filter(r => (r[colorField] || '(empty)') === colorVal);
        let x = colorRows.map(r => r[xField]);
        let y = colorRows.map(r => r[yField]);
        
        // Handle categorical axis encoding
        if (xType === 'categorical' && cfg.encodeCategorical) {
          const encoded = encodeCategorical(x);
          x = encoded.values;
          if (cfg.addJitter) x = jitter(x);
        }
        if (yType === 'categorical' && cfg.encodeCategorical) {
          const encoded = encodeCategorical(y);
          y = encoded.values;
          if (cfg.addJitter) y = jitter(y);
        }
        
        const trace = { 
          x, y, 
          mode: 'markers', 
          type: 'scatter', 
          name: colorVal === '(empty)' ? '(empty)' : colorVal 
        };
        
        if (cfg.type === 'bubble' && cfg.size) {
          const s = colorRows.map(r => +r[cfg.size]);
          const min = Math.min(...s.filter(v => !Number.isNaN(v)));
          const max = Math.max(...s.filter(v => !Number.isNaN(v)));
          const scaled = s.map(v => Number.isNaN(v) ? 5 : (10 + 30 * ((v - min) / Math.max(1e-9, max - min))));
          trace.marker = { size: scaled, sizemode: 'diameter', opacity: 0.7 };
        }
        
        fig.data.push(trace);
      }
      
    } else if (colorField && colorType === 'numeric') {
      // Single trace with color scale
      let x = data.map(r => r[xField]);
      let y = data.map(r => r[yField]);
      const colorValues = data.map(r => +r[colorField]);
      
      // Handle categorical axis encoding
      if (xType === 'categorical' && cfg.encodeCategorical) {
        const encoded = encodeCategorical(x);
        x = encoded.values;
        if (cfg.addJitter) x = jitter(x);
      }
      if (yType === 'categorical' && cfg.encodeCategorical) {
        const encoded = encodeCategorical(y);
        y = encoded.values;
        if (cfg.addJitter) y = jitter(y);
      }
      
      const trace = { 
        x, y, 
        mode: 'markers', 
        type: 'scatter', 
        name: yField,
        marker: {
          color: colorValues,
          colorscale: 'Viridis',
          showscale: true,
          colorbar: { title: colorField }
        }
      };
      
      if (cfg.type === 'bubble' && cfg.size) {
        const s = data.map(r => +r[cfg.size]);
        const min = Math.min(...s.filter(v => !Number.isNaN(v)));
        const max = Math.max(...s.filter(v => !Number.isNaN(v)));
        const scaled = s.map(v => Number.isNaN(v) ? 5 : (10 + 30 * ((v - min) / Math.max(1e-9, max - min))));
        trace.marker.size = scaled;
        trace.marker.sizemode = 'diameter';
        trace.marker.opacity = 0.7;
      }
      
      fig.data.push(trace);
      
    } else {
      // No color or invalid color
      let x = data.map(r => r[xField]);
      let y = data.map(r => r[yField]);
      
      // Handle categorical axis encoding
      if (xType === 'categorical' && cfg.encodeCategorical) {
        const encoded = encodeCategorical(x);
        x = encoded.values;
        if (cfg.addJitter) x = jitter(x);
      }
      if (yType === 'categorical' && cfg.encodeCategorical) {
        const encoded = encodeCategorical(y);
        y = encoded.values;
        if (cfg.addJitter) y = jitter(y);
      }
      
      const trace = { x, y, mode: 'markers', type: 'scatter', name: yField };
      
      if (cfg.type === 'bubble' && cfg.size) {
        const s = data.map(r => +r[cfg.size]);
        const min = Math.min(...s.filter(v => !Number.isNaN(v)));
        const max = Math.max(...s.filter(v => !Number.isNaN(v)));
        const scaled = s.map(v => Number.isNaN(v) ? 5 : (10 + 30 * ((v - min) / Math.max(1e-9, max - min))));
        trace.marker = { size: scaled, sizemode: 'diameter', opacity: 0.7 };
      }
      
      fig.data.push(trace);
    }
    
    fig.layout.xaxis = { title: xField };
    fig.layout.yaxis = { title: yField };
  }

  function drawPie(cfg, data, fig) {
    if (!cfg.x) return;
    
    const xField = cfg.x;
    const xType = getColumnType(xField);
    
    const agg = (rows) => {
      if (cfg.agg === 'count') return rows.length;
      if (!cfg.y) return rows.length;
      const vals = rows.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
      if (!vals.length) return 0;
      if (cfg.agg === 'sum') return vals.reduce((a,b)=>a+b,0);
      return vals.reduce((a,b)=>a+b,0) / vals.length;
    };
    
    if (xType === 'categorical') {
      // Standard categorical pie
      const groups = {};
      data.forEach(r => {
        const key = String(r[xField] || '(empty)');
        (groups[key] ||= []).push(r);
      });
      
      const labels = Object.keys(groups);
      const values = labels.map(k => agg(groups[k]));
      fig.data.push({ labels, values, type: 'pie', hole: .35 });
      
    } else if (xType === 'numeric') {
      // Auto-bin numeric X
      const xVals = data.map(r => r[xField]).filter(v => typeof v === 'number' && !isNaN(v));
      const binData = binNumeric(xVals, cfg.xBins || 30);
      
      const labels = binData.bins.map(b => b.toFixed(1));
      const values = binData.counts;
      fig.data.push({ labels, values, type: 'pie', hole: .35 });
      
    } else if (xType === 'date') {
      // Auto-bin date X
      const xVals = data.map(r => r[xField]).filter(v => v != null);
      const binData = binDates(xVals, cfg.xPeriod || 'month');
      
      fig.data.push({ labels: binData.labels, values: binData.counts, type: 'pie', hole: .35 });
    }
  }

  function drawBox(cfg, data, fig) {
    if (!cfg.y) { 
      // No Y field selected - will be handled by the main drawChart function
      return; 
    }
    
    const xField = cfg.x;
    const yField = cfg.y;
    const yType = getColumnType(yField);
    
    if (yType !== 'numeric') {
      // Fallback to frequency bar chart
      const groups = {};
      data.forEach(r => {
        const key = String(r[yField] || '(empty)');
        groups[key] = (groups[key] || 0) + 1;
      });
      
      const labels = Object.keys(groups).sort();
      const values = labels.map(k => groups[k]);
      
      fig.data.push({ x: labels, y: values, type: 'bar', name: 'Count' });
      fig.layout.title += ' (auto-converted: non-numeric Y)';
      fig.layout.xaxis = { title: yField };
      fig.layout.yaxis = { title: 'Count' };
    } else {
      // Standard box plot
      if (xField) {
        const xType = getColumnType(xField);
        
        if (xType === 'categorical') {
          const groups = {};
          data.forEach(r => {
            const key = String(r[xField] || '(empty)');
            const val = +r[yField];
            if (!Number.isNaN(val)) {
              (groups[key] ||= []).push(val);
            }
          });
          
          Object.keys(groups).forEach(k => 
            fig.data.push({ y: groups[k], name: k, type: 'box' }));
            
        } else {
          // Auto-bin numeric/date X
          let binData;
          if (xType === 'numeric') {
            const xVals = data.map(r => r[xField]).filter(v => typeof v === 'number' && !isNaN(v));
            binData = binNumeric(xVals, cfg.xBins || 30);
            
            binData.bins.forEach((binCenter, i) => {
              const binMin = binCenter - binData.binWidth / 2;
              const binMax = binCenter + binData.binWidth / 2;
              const binRows = data.filter(r => {
                const xVal = r[xField];
                return typeof xVal === 'number' && !isNaN(xVal) && xVal >= binMin && xVal < binMax;
              });
              const yVals = binRows.map(r => +r[yField]).filter(v => !Number.isNaN(v));
              if (yVals.length > 0) {
                fig.data.push({ y: yVals, name: `${binCenter.toFixed(1)}`, type: 'box' });
              }
            });
          } else if (xType === 'date') {
            const xVals = data.map(r => r[xField]).filter(v => v != null);
            binData = binDates(xVals, cfg.xPeriod || 'month');
            
            binData.labels.forEach(label => {
              const binRows = data.filter(r => {
                const period = cfg.xPeriod || 'month';
                const d = new Date(r[xField]);
                if (isNaN(d)) return false;
                
                let key;
                const year = d.getUTCFullYear();
                const month = String(d.getUTCMonth() + 1).padStart(2, '0');
                
                switch (period) {
                  case 'day': key = d.toISOString().slice(0, 10); break;
                  case 'month': key = `${year}-${month}`; break;
                  case 'quarter': 
                    const quarter = Math.floor((d.getUTCMonth() + 3) / 3);
                    key = `Q${quarter} ${year}`; break;
                  case 'year': key = String(year); break;
                  default: key = `${year}-${month}`;
                }
                return key === label;
              });
              const yVals = binRows.map(r => +r[yField]).filter(v => !Number.isNaN(v));
              if (yVals.length > 0) {
                fig.data.push({ y: yVals, name: label, type: 'box' });
              }
            });
          }
        }
      } else {
        // No X field - single box for all Y values
        const yVals = data.map(r => +r[yField]).filter(v => !Number.isNaN(v));
        fig.data.push({ y: yVals, name: yField, type: 'box' });
      }
      
      fig.layout.xaxis = { title: xField || 'Category' };
      fig.layout.yaxis = { title: yField };
      
      if (cfg.histOverlay) {
        // Fix: prevent null/empty coercion to 0 in histogram overlay
        const vals = data
          .map(r => r[yField])
          .filter(v => v != null && v !== '')  // Remove null, undefined, empty string first
          .map(v => Number(v))                 // Convert to number
          .filter(v => Number.isFinite(v));    // Keep only finite numbers
        fig.data.push({ x: vals, type: 'histogram', opacity: 0.3, xaxis: 'x2', yaxis: 'y2', name: 'Histogram' });
        fig.layout.grid = { rows: 1, columns: 2, pattern: 'independent' };
        fig.layout.title += ' · + Histogram';
      }
    }
  }

  function drawBarLine(cfg, data, fig) {
    // Keep existing barline implementation
    const groupBy = (rows, keys) => {
      const map = new Map();
      for (const r of rows) {
        const key = keys.map(k => String(r[k])).join('¦');
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(r);
      }
      return { map, keys };
    };
    
    const g = groupBy(data, [cfg.x]);
    const xs = Array.from(g.map.keys()).map(k => k.split('¦')[0]).sort((a,b)=>String(a).localeCompare(String(b)));
    const aggSeries = (yField) => xs.map(xv => {
      const rows = g.map.get(String(xv)) || g.map.get(xv) || [];
      if (!yField) return 0;
      const vals = rows.map(r => +r[yField]).filter(v => !Number.isNaN(v));
      if (!vals.length) return 0;
      if (cfg.agg === 'sum') return vals.reduce((a,b)=>a+b,0);
      if (cfg.agg === 'mean') return vals.reduce((a,b)=>a+b,0)/vals.length;
      return rows.length;
    });
    const yBar = aggSeries(cfg.y);
    const yLine = aggSeries(cfg.y2);

    fig.data.push({ x: xs, y: yBar, type: 'bar', name: `${cfg.agg}(${cfg.y})` });
    const lineTrace = { x: xs, y: yLine, type: 'scatter', mode: 'lines+markers', name: `${cfg.agg}(${cfg.y2})` };
    if (cfg.dualAxis) { lineTrace.yaxis = 'y2'; fig.layout.yaxis2 = { overlaying: 'y', side: 'right' }; }
    fig.data.push(lineTrace);
    fig.layout.xaxis = { title: cfg.x };
  }

  function drawHeatmap(cfg, data, fig) {
    // Keep existing heatmap implementation
    const M = makePivotMatrix(data, cfg.x, cfg.yCat, cfg.y, cfg.agg);
    fig.data.push({ z: M.z, x: M.cols, y: M.rows, type: 'heatmap', colorscale: 'Viridis' });
    fig.layout.xaxis = { title: cfg.yCat };
    fig.layout.yaxis = { title: cfg.x };
  }

  function drawFunnel(cfg, data, fig) {
    // Keep existing funnel implementation
    const groupBy = (rows, keys) => {
      const map = new Map();
      for (const r of rows) {
        const key = keys.map(k => String(r[k])).join('¦');
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(r);
      }
      return { map, keys };
    };
    
    const agg = (rows) => {
      if (cfg.agg === 'count') return rows.length;
      const vals = rows.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
      if (!vals.length) return 0;
      if (cfg.agg === 'sum')  return vals.reduce((a,b)=>a+b,0);
      return vals.reduce((a,b)=>a+b,0) / vals.length; // mean
    };
    
    const g = groupBy(data, [cfg.x]);
    const labels = Array.from(g.map.keys()).map(k => k.split('¦')[0]);
    const values = labels.map(l => agg(g.map.get(String(l)) || []));
    const sorted = labels.map((l,i)=>({l, v: values[i]})).sort((a,b)=>b.v-a.v);
    fig.data.push({ type: 'funnel', y: sorted.map(s=>s.l), x: sorted.map(s=>s.v) });
  }

  // ----------------------------
  // Resize Observer for Auto-Resizing Plotly Charts
  // ----------------------------
  function initPlotlyResizeObserver() {
    if (!window.ResizeObserver) return; // Fallback for browsers without ResizeObserver

    const resizeObserver = new ResizeObserver((entries) => {
      entries.forEach((entry) => {
        const plotElement = entry.target;
        // Check if this is a plot element that contains a Plotly chart
        if (plotElement.classList.contains('plot') && plotElement.children.length > 0) {
          // Find the corresponding chart configuration
          const chart = charts.find(cfg => cfg._el === plotElement);
          if (chart) {
            // Debounce the resize to avoid excessive redraws
            clearTimeout(plotElement._resizeTimeout);
            plotElement._resizeTimeout = setTimeout(() => {
              try {
                Plotly.Plots.resize(plotElement);
              } catch (e) {
                console.warn('Error resizing Plotly chart:', e);
              }
            }, 100);
          }
        }
      });
    });

    // Store globally for access in addChart
    window.plotlyResizeObserver = resizeObserver;

    // Observe all existing plot elements
    const observeExistingPlots = () => {
      document.querySelectorAll('.plot').forEach(plotEl => {
        resizeObserver.observe(plotEl);
      });
    };

    // Initialize observation of existing plots
    observeExistingPlots();

    return resizeObserver;
  }

  // ===================== Preview Renderer & Filter Pipeline =====================
  
  // PreviewRenderer helper for paginated Data Preview
  const PreviewRenderer = {
    currentPage: 0,
    rowsPerPage: 15,
    
    renderRows(rows) {
      const wrap = document.getElementById('tableWrap');
      if (!wrap) return;
      
      console.debug('PreviewRenderer.renderRows called with', rows.length, 'rows');
      
      wrap.innerHTML = '';
      if (!rows.length) {
        wrap.innerHTML = '<div class="text-muted">No data to display</div>';
        return;
      }
      
      // Create table with scroll wrapper
      const scrollWrapper = document.createElement('div');
      scrollWrapper.className = 'data-preview-scroll';
      
      const table = document.createElement('table');
      table.className = 'table table-sm table-striped';
      
      // Create header
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      for (const col of (columns || [])) {
        const th = document.createElement('th');
        th.textContent = col;
        trh.appendChild(th);
      }
      thead.appendChild(trh);
      
      // Create tbody (initially empty)
      const tbody = document.createElement('tbody');
      tbody.id = 'preview-tbody';
      
      table.appendChild(thead);
      table.appendChild(tbody);
      scrollWrapper.appendChild(table);
      wrap.appendChild(scrollWrapper);
      
      // Render first page
      this.currentPage = 0;
      this.appendRows(rows);
      
      // Add scroll listener for pagination
      scrollWrapper.addEventListener('scroll', () => {
        if (scrollWrapper.scrollTop + scrollWrapper.clientHeight >= scrollWrapper.scrollHeight - 50) {
          this.appendRows(rows);
        }
      });
    },
    
    appendRows(rows) {
      const tbody = document.getElementById('preview-tbody');
      if (!tbody || !rows.length) return;
      
      const startIdx = this.currentPage * this.rowsPerPage;
      const endIdx = Math.min((this.currentPage + 1) * this.rowsPerPage, rows.length);
      
      if (startIdx >= rows.length) return; // No more rows to add
      
      const rowsToAdd = rows.slice(startIdx, endIdx);
      console.debug('PreviewRenderer.appendRows adding', rowsToAdd.length, 'rows (page', this.currentPage, ')');
      
      for (const row of rowsToAdd) {
        const tr = document.createElement('tr');
        for (const col of (columns || [])) {
          const td = document.createElement('td');
          const value = row[col];
          td.textContent = (value === undefined || value === null) ? '' : value;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      
      this.currentPage++;
    }
  };
  
  // Debounce helper
  let filterPipelineTimeout = null;
  
  // Unified filter application pipeline
  function applyFiltersPipeline(live = false) {
    console.debug('applyFiltersPipeline called with live =', live);
    
    if (live) {
      // Debounce live updates
      if (filterPipelineTimeout) clearTimeout(filterPipelineTimeout);
      filterPipelineTimeout = setTimeout(() => {
        _executeFilterPipeline(true);
      }, 80);
    } else {
      // Immediate execution for Apply button
      if (filterPipelineTimeout) clearTimeout(filterPipelineTimeout);
      return _executeFilterPipeline(false);
    }
  }
  
  function _executeFilterPipeline(live) {
    console.debug('_executeFilterPipeline executing with live =', live);
    
    // Apply unified filtering: both Simple filters AND Global Filters must pass
    filteredRows = rawData.filter(row => {
      return passesSimpleFilters(row) && passesGlobalFilters(row);
    });
    
    // Update legacy variable for backward compatibility
    filtered = filteredRows;
    
    console.debug('Filtered rows count:', filteredRows.length);
    
    // Render preview (first page only)
    if (typeof PreviewRenderer !== 'undefined' && PreviewRenderer.renderRows) {
      PreviewRenderer.renderRows(filteredRows);
    }
    
    // Update inspector summary
    if (typeof updateInspectorSummary === 'function') {
      updateInspectorSummary(filteredRows);
    }
    
    // Redraw charts
    if (charts && charts.forEach && typeof drawChart === 'function') {
      charts.forEach(drawChart);
    }
    
    // For non-live mode, also update the main table
    if (!live && typeof updateTable === 'function') {
      updateTable();
    }
    
    return filteredRows;
  }

  // ===================== Inspector logic =====================
  function updateInspectorSummary(filteredData) {
    const totalRowsEl = id('sumTotalRows');
    const totalColsEl = id('sumTotalCols');
    const filteredRowsEl = id('sumFilteredRows');
    const dateRangeEl = id('sumDateRange');
    
    // Use provided filteredData, fallback to filteredRows
    const filtered = filteredData || filteredRows;
    
    if (totalRowsEl) totalRowsEl.textContent = rawData?.length ? rawData.length.toLocaleString() : '0';
    if (totalColsEl) totalColsEl.textContent = columns?.length ? columns.length.toLocaleString() : '0';
    if (filteredRowsEl) filteredRowsEl.textContent = filtered?.length ? filtered.length.toLocaleString() : '0';

    if (!dateCol || !dateRangeEl) { 
      if (dateRangeEl) dateRangeEl.textContent = '—'; 
      return; 
    }

    const rowsForRange = (filtered && Array.isArray(filtered)) ? filtered : rawData;
    if (typeof parseValidDate === 'function' && typeof toISO === 'function') {
      const dates = rowsForRange
        .map(r => parseValidDate(r[dateCol]))
        .filter(Boolean)
        .sort((a,b) => a - b);

      dateRangeEl.textContent =
        dates.length ? `${toISO(dates[0])} → ${toISO(dates[dates.length-1])}` : '—';
    }
  }

  function rebuildInspectorColumnList() {
    const wrap = id('inspectorList');
    if (!wrap) return;
    
    wrap.innerHTML = '';
    if (!columns?.length) return;

    const frag = document.createDocumentFragment();
    columns.forEach(col => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = col;
      btn.dataset.col = col;
      frag.appendChild(btn);
    });
    wrap.appendChild(frag);

    wrap.onclick = (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      inspectorSelectedField = btn.dataset.col;
      wrap.querySelectorAll('button').forEach(b =>
        b.classList.toggle('active', b === btn)
      );
      showFieldStats(inspectorSelectedField);
    };

    inspectorSelectedField = columns[0];
    const firstBtn = wrap.querySelector('button');
    if (firstBtn) firstBtn.classList.add('active');
    showFieldStats(inspectorSelectedField);
  }

  function showFieldStats(col) {
    if (!col) return;
    
    const fieldNameEl = id('fieldName');
    const fieldStatsEl = id('fieldStats');
    
    if (fieldNameEl) fieldNameEl.textContent = col;
    if (!fieldStatsEl) return;

    const vals = (filteredRows || []).map(r => r[col]);
    const nonNull = vals.filter(v => v !== null && v !== undefined && v !== '');

    const isNumeric = numericCols.includes(col);
    const isDate = (col === dateCol);

    const fmtLocal = (x, d=3) =>
      (x === undefined || x === null || Number.isNaN(x)) ? '—'
        : Number(x).toLocaleString(undefined, { maximumFractionDigits: d });

    const percent = (num, den) =>
      (den ? (100 * num / den) : 0).toLocaleString(undefined, { maximumFractionDigits: 1 }) + '%';

    const topN = (arr, n=5) => {
      const m = new Map();
      arr.forEach(v => m.set(v, (m.get(v)||0)+1));
      return [...m.entries()].sort((a,b) => b[1]-a[1]).slice(0, n);
    };

    const qtile = (sorted, q) => {
      if (!sorted.length) return NaN;
      const pos = (sorted.length - 1) * q;
      const base = Math.floor(pos);
      const rest = pos - base;
      return (sorted[base+1] !== undefined)
        ? sorted[base] + rest * (sorted[base+1] - sorted[base])
        : sorted[base];
    };

    let html = '';

    const asStr = nonNull.map(v => String(v));
    const totalCount = vals.length;
    let distribution = [];
    if (isNumeric) {
      const nums = nonNull.map(Number).filter(v => !Number.isNaN(v));
      if (nums.length) {
        const minVal = Math.min(...nums);
        const maxVal = Math.max(...nums);
        const binCount = 5;
        let width = (maxVal - minVal) / binCount;
        if (width === 0) width = 1;
        const bins = Array(binCount).fill(0);
        const labels = [];
        for (let i = 0; i < binCount; i++) {
          const start = minVal + width * i;
          const end   = (i === binCount - 1) ? maxVal : minVal + width * (i + 1);
          labels.push(`${fmtLocal(start)}–${fmtLocal(end)}`);
        }
        nums.forEach(v => {
          let idx = Math.floor((v - minVal) / width);
          if (idx < 0) idx = 0;
          if (idx >= binCount) idx = binCount - 1;
          bins[idx]++;
        });
        distribution = labels.map((lab, i) => ({ label: lab, count: bins[i] }));
        distribution = distribution.filter(item => item.count > 0);
      }
    } else {
      const m = new Map();
      asStr.forEach(v => m.set(v, (m.get(v) || 0) + 1));
      const entries = [...m.entries()].sort((a,b) => b[1] - a[1]);
      const top = entries.slice(0, 5);
      const otherCount = entries.slice(5).reduce((s, [,c]) => s + c, 0);
      distribution = top.map(([label, count]) => ({ label, count }));
      if (otherCount > 0) distribution.push({ label: 'Other', count: otherCount });
    }
    html += `
      <div class="mb-2">
        <h6 class="mb-1">Data Distribution Overview</h6>
        <table class="table table-sm mb-2">
          <thead><tr><th>Value</th><th class="text-end">Share</th></tr></thead>
          <tbody>
            ${distribution.map(row => `<tr><td>${row.label}</td><td class="text-end">${percent(row.count, totalCount)}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    `;

    const filled = nonNull.length;
    const uniqueCount = new Set(asStr).size;
    const avgLen = asStr.length ? (asStr.reduce((s, v) => s + v.length, 0) / asStr.length) : 0;
    const avgLenDisplay = (avgLen && !Number.isNaN(avgLen)) ? fmtLocal(avgLen, 2) : '—';
    html += `
      <div class="mb-2">
        <h6 class="mb-1">Data Quality Metrics</h6>
        <table class="table table-sm mb-2">
          <tbody>
            <tr><th class="text-muted">Filled percentage</th><td>${percent(filled, vals.length)}</td></tr>
            <tr><th class="text-muted">Filled values</th><td>${filled.toLocaleString()}</td></tr>
            <tr><th class="text-muted">Avg. Length</th><td>${avgLenDisplay}</td></tr>
            <tr><th class="text-muted">Unique Items</th><td>${uniqueCount.toLocaleString()}</td></tr>
            <tr><th class="text-muted">Uniqueness</th><td>${percent(uniqueCount, filled)}</td></tr>
          </tbody>
        </table>
      </div>
    `;

    if (isNumeric) {
      const nums = nonNull.map(Number).filter(v => !Number.isNaN(v)).sort((a,b)=>a-b);
      const n = nums.length;
      const mean = n ? nums.reduce((a,b)=>a+b,0)/n : 0;
      const std = (n>1) ? Math.sqrt(nums.reduce((s,v)=>s+(v-mean)**2,0)/(n-1)) : 0;
      const zeros = nums.filter(v => v === 0).length;
      const rsd = mean !== 0 ? (std/mean)*100 : 0;

      html += `
        <div>
          <h6 class="mb-1">Summary Statistics</h6>
          <table class="table table-sm mb-0">
            <tbody>
              <tr><th class="text-muted">Mean</th><td>${fmtLocal(mean)}</td></tr>
              <tr><th class="text-muted">Min</th><td>${fmtLocal(nums[0])}</td></tr>
              <tr><th class="text-muted">Max</th><td>${fmtLocal(nums[n-1])}</td></tr>
              <tr><th class="text-muted">Std Dev</th><td>${fmtLocal(std)}</td></tr>
              <tr><th class="text-muted">Relative Std Dev</th><td>${fmtLocal(rsd,1)}%</td></tr>
              <tr><th class="text-muted">Zero Values</th><td>${zeros.toLocaleString()} (${percent(zeros, n)})</td></tr>
              <tr><th class="text-muted">25%</th><td>${fmtLocal(qtile(nums, 0.25))}</td></tr>
              <tr><th class="text-muted">50% (Median)</th><td>${fmtLocal(qtile(nums, 0.50))}</td></tr>
              <tr><th class="text-muted">75%</th><td>${fmtLocal(qtile(nums, 0.75))}</td></tr>
            </tbody>
          </table>
        </div>
      `;
    } else if (isDate) {
      const dates = nonNull.map(v => new Date(v)).filter(d => !isNaN(d)).sort((a,b)=>a-b);
      const uniq = new Set(dates.map(d => d.getTime()));
      html += `
        <div>
          <h6 class="mb-1">Summary (Date)</h6>
          <table class="table table-sm mb-0">
            <tbody>
              <tr><th class="text-muted">Count</th><td>${dates.length.toLocaleString()}</td></tr>
              <tr><th class="text-muted">Unique</th><td>${uniq.size.toLocaleString()}</td></tr>
              <tr><th class="text-muted">Min</th><td>${dates.length ? toISO(dates[0]) : '—'}</td></tr>
              <tr><th class="text-muted">Max</th><td>${dates.length ? toISO(dates[dates.length-1]) : '—'}</td></tr>
            </tbody>
          </table>
        </div>
      `;
    } else {
      const counts = new Map();
      asStr.forEach(v => counts.set(v, (counts.get(v) || 0) + 1));
      let topVal = '—', topFreq = 0;
      for (const [k, v] of counts.entries()) if (v > topFreq) { topVal = k; topFreq = v; }
      const lengths = asStr.map(v => v.length);
      const minLen = lengths.length ? Math.min(...lengths) : 0;
      const maxLen = lengths.length ? Math.max(...lengths) : 0;

      html += `
        <div>
          <h6 class="mb-1">Summary (Categorical/Text)</h6>
          <table class="table table-sm mb-0">
            <tbody>
              <tr><th class="text-muted">Count</th><td>${asStr.length.toLocaleString()}</td></tr>
              <tr><th class="text-muted">Unique</th><td>${counts.size.toLocaleString()}</td></tr>
              <tr><th class="text-muted">Top</th><td>${topVal}</td></tr>
              <tr><th class="text-muted">Freq</th><td>${topFreq.toLocaleString()} (${percent(topFreq, asStr.length)})</td></tr>
              <tr><th class="text-muted">Min Length</th><td>${minLen.toLocaleString()}</td></tr>
              <tr><th class="text-muted">Max Length</th><td>${maxLen.toLocaleString()}</td></tr>
            </tbody>
          </table>
        </div>
      `;
    }

    fieldStatsEl.innerHTML = html;
  }

  function fmt(x) {
    if (x === undefined || x === null || Number.isNaN(x)) return '—';
    return Number(x).toLocaleString(undefined, { maximumFractionDigits: 3 });
  }
  function quantile(sortedNums, q) {
    if (!sortedNums.length) return NaN;
    const pos = (sortedNums.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if (sortedNums[base+1] !== undefined) {
      return sortedNums[base] + rest * (sortedNums[base+1] - sortedNums[base]);
    }
    return sortedNums[base];
  }

  // ----------------------------
  // Utilities
  // ----------------------------
  const id = (s) => document.getElementById(s);
  const toISO = (d) => new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().split('T')[0];
  const uniqueNonEmpty = (arr) => Array.from(new Set(arr.map(v => v===null||v===undefined?'' : String(v)).filter(s => s !== ''))).sort();

  function parseValidDate(v) {
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return null;
    const y = d.getUTCFullYear();
    return (y >= 2019 && y <= 2100) ? d : null;
  }

  function appendOption(sel, value, label) {
    if (!sel) return;
    const o = document.createElement('option');
    o.value = value; o.textContent = label ?? value;
    sel.appendChild(o);
  }

  function setSelectOptions(sel, values, includeBlank, blankLabel) {
    if (!sel) return;
    sel.innerHTML = '';
    if (includeBlank) {
      appendOption(sel, '', blankLabel || '');
    }
    values.forEach(v => appendOption(sel, v));
  }

  // This function is now replaced by optgroups in populateBuilderSelects
  function updateBuilderRoleOptionsByType() {
    // No longer needed - all selects now use optgroups with all columns
  }
  function fillMultiSelect(sel, values) {
    sel.innerHTML = '';
    for (const v of values) {
      const o = document.createElement('option');
      o.value = v; o.textContent = v; o.selected = true;
      sel.appendChild(o);
    }
  }
  function selectAll(sel){ for (const o of sel.options) o.selected = true; sel.dispatchEvent(new Event('change')); }
  function clearAll(sel){ for (const o of sel.options) o.selected = false; sel.dispatchEvent(new Event('change')); }

  function toggle(panelId) {
    const el = id(panelId);
    if (el) el.classList.toggle('active');
  }
  function show(panelId, on=true) {
    const el = id(panelId);
    if (el) {
      if (on) el.classList.add('active'); 
      else el.classList.remove('active');
    }
  }
  function openModal(){ 
    const modal = id('modal');
    if (modal) modal.style.display = 'grid'; 
  }
  function closeModal(){ 
    const modal = id('modal');
    if (modal) modal.style.display = 'none'; 
  }

  function downloadCSV(filename, headers, rows) {
    const esc = (v) => {
      if (v === null || v === undefined) return '';
      const s = String(v);
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    };
    const csv = [headers.map(esc).join(',')]
      .concat(rows.map(row => row.map(esc).join(',')))
      .join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  // ----------------------------
  // Chart Edit FAB Functions
  // ----------------------------
  function attachEditFab(card, cfg) {
    const plotEl = card.querySelector('.plot');
    if (!plotEl) return;

    // Create FAB element
    const fab = document.createElement('button');
    fab.className = 'chart-edit-fab';
    fab.title = 'Edit chart';
    fab.setAttribute('aria-label', 'Edit chart');
    fab.tabIndex = 0;
    fab.innerHTML = '<i class="bi bi-pencil-square"></i>';

    // Insert FAB into the plot container
    plotEl.style.position = 'relative';
    plotEl.appendChild(fab);

    // Hover detection for proximity to top-right corner
    let isNearCorner = false;
    let fabVisible = false;

    const checkProximity = (e) => {
      const rect = plotEl.getBoundingClientRect();
      const proximityZone = 60; // 60px proximity zone
      
      const distFromTopRight = Math.sqrt(
        Math.pow(e.clientX - (rect.right - proximityZone/2), 2) + 
        Math.pow(e.clientY - (rect.top + proximityZone/2), 2)
      );
      
      isNearCorner = distFromTopRight <= proximityZone;
      updateFabVisibility();
    };

    const updateFabVisibility = () => {
      const shouldShow = isNearCorner || fab === document.activeElement;
      if (shouldShow !== fabVisible) {
        fabVisible = shouldShow;
        if (fabVisible) {
          fab.classList.add('visible');
        } else {
          fab.classList.remove('visible');
        }
      }
    };

    // Event listeners
    card.addEventListener('mousemove', checkProximity);
    card.addEventListener('mouseleave', () => {
      isNearCorner = false;
      updateFabVisibility();
    });

    fab.addEventListener('focus', updateFabVisibility);
    fab.addEventListener('blur', updateFabVisibility);
    
    fab.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      openEditModal(cfg);
    });

    fab.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        openEditModal(cfg);
      }
    });
  }

  function openEditModal(cfg) {
    editingChart = cfg;
    
    // Populate form with current config
    populateBuilderFromConfig(cfg);
    
    // Change modal title and button text
    const modalTitle = id('modalTitle');
    const btnCreate = id('btnCreate');
    if (modalTitle) modalTitle.textContent = 'Edit chart';
    if (btnCreate) btnCreate.textContent = 'Update chart';
    
    // Update builder visibility based on current config
    updateBuilderVisibility();
    updateAdvancedVisibility();
    updateTransformationSummary();
    
    // Open modal
    openModal();
  }

  function populateBuilderFromConfig(cfg) {
    // Basic fields
    if (id('fldType')) id('fldType').value = cfg.type || 'bar';
    if (id('fldX')) id('fldX').value = cfg.x || '';
    if (id('fldY')) id('fldY').value = cfg.y || '';
    if (id('fldY2')) id('fldY2').value = cfg.y2 || '';
    if (id('fldYCat')) id('fldYCat').value = cfg.yCat || '';
    if (id('fldColor')) id('fldColor').value = cfg.color || '';
    if (id('fldSize')) id('fldSize').value = cfg.size || '';
    if (id('fldAgg')) id('fldAgg').value = cfg.agg || 'count';
    
    // Checkboxes
    if (id('chkDualAxis')) id('chkDualAxis').checked = cfg.dualAxis || false;
    if (id('chkHistOverlay')) id('chkHistOverlay').checked = cfg.histOverlay || false;
    
    // Advanced options
    if (id('fldXBins')) id('fldXBins').value = cfg.xBins || 30;
    if (id('fldXPeriod')) id('fldXPeriod').value = cfg.xPeriod || 'month';
    if (id('fldXOrder')) id('fldXOrder').value = cfg.xOrder || 'alphabetical';
    if (id('chkEncodeCategorical')) id('chkEncodeCategorical').checked = cfg.encodeCategorical || false;
    if (id('chkAddJitter')) id('chkAddJitter').checked = cfg.addJitter || false;
    if (id('chkShowRangeslider')) id('chkShowRangeslider').checked = cfg.showRangeslider || false;
  }

  function readBuilderToConfig(cfg) {
    // Update config with form values
    cfg.type = id('fldType')?.value || 'bar';
    cfg.x = id('fldX')?.value || null;
    cfg.y = id('fldY')?.value || null;
    cfg.y2 = id('fldY2')?.value || null;
    cfg.yCat = id('fldYCat')?.value || null;
    cfg.color = id('fldColor')?.value || null;
    cfg.size = id('fldSize')?.value || null;
    cfg.agg = id('fldAgg')?.value || 'count';
    cfg.dualAxis = id('chkDualAxis')?.checked || false;
    cfg.histOverlay = id('chkHistOverlay')?.checked || false;
    
    // Advanced options
    cfg.xBins = parseInt(id('fldXBins')?.value) || 30;
    cfg.xPeriod = id('fldXPeriod')?.value || 'month';
    cfg.xOrder = id('fldXOrder')?.value || 'alphabetical';
    cfg.encodeCategorical = id('chkEncodeCategorical')?.checked || false;
    cfg.addJitter = id('chkAddJitter')?.checked || false;
    cfg.showRangeslider = id('chkShowRangeslider')?.checked || false;
    
    return cfg;
  }

  function resetModalToCreateMode() {
    editingChart = null;
    const modalTitle = id('modalTitle');
    const btnCreate = id('btnCreate');
    if (modalTitle) modalTitle.textContent = 'Create chart';
    if (btnCreate) btnCreate.textContent = 'Create';
  }

  // ----------------------------
  // Filters Panel Resize Functionality
  // ----------------------------
  function initFiltersResize() {
    const handle = document.getElementById('filtersResizeHandle');
    const panel = document.getElementById('filters-panel');
    
    if (!handle || !panel) return;
    
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = parseInt(window.getComputedStyle(panel).width, 10);
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      // Prevent text selection during resize
      document.body.style.userSelect = 'none';
      panel.style.transition = 'none';
      
      e.preventDefault();
    });
    
    function handleMouseMove(e) {
      if (!isResizing) return;
      
      const deltaX = e.clientX - startX;
      const newWidth = startWidth + deltaX;
      
      // Set min and max constraints
      const minWidth = 600;
      const maxWidth = window.innerWidth * 0.9;
      
      if (newWidth >= minWidth && newWidth <= maxWidth) {
        panel.style.width = newWidth + 'px';
      }
    }
    
    function handleMouseUp() {
      if (!isResizing) return;
      
      isResizing = false;
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      
      // Restore text selection and transition
      document.body.style.userSelect = '';
      panel.style.transition = '';
    }
  }

  // Initialize resize functionality when filters are ready
  document.addEventListener('DOMContentLoaded', () => {
    // Small delay to ensure the Global Filters modal is properly initialized
    setTimeout(initFiltersResize, 100);
  });
  </script>

  <!-- ==================== Global Filters Modal (your inserted block) ==================== -->
  <style>
    #panelFilters{ display:none; }
    
    /* Ensure modal displays properly */
    #filters-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    
    #filters-backdrop.show {
      display: flex !important;
    }
    
    /* Remove conflicting styles */
    .filters-modal-backdrop {
      display: none !important;
    }
    
    /* Additional styles for better modal appearance */
    #filters-panel {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 12px 40px rgba(0,0,0,.2);
      max-height: 90vh;
      overflow: auto;
    }
    :root{
  --gf-radius-lg: 16px;
  --gf-radius-sm: 10px;
  --gf-border: #e8ecf0;
  --gf-panel: #f7f9fb;
  --gf-soft: #eef6f9;
  --gf-text: #2b2f36;
  --gf-muted: #6b7280;
  --gf-shadow: 0 10px 30px rgba(0,0,0,.08);
}

/* Panel */
#filters-panel{
  border-radius: var(--gf-radius-lg);
  background: #fff;
  box-shadow: var(--gf-shadow);
  border: 1px solid var(--gf-border);
  resize: horizontal;
  overflow: auto;
  min-width: 800px;
  max-width: 90vw;
}

/* Resize handle for filters panel */
#filtersResizeHandle {
  position: absolute;
  top: 0;
  right: 0;
  width: 20px;
  height: 100%;
  background: linear-gradient(90deg, transparent 0%, #e1e5e9 50%, transparent 100%);
  cursor: ew-resize;
  user-select: none;
  border-top-right-radius: var(--gf-radius-lg);
  border-bottom-right-radius: var(--gf-radius-lg);
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

#filtersResizeHandle:hover {
  opacity: 1;
  background: linear-gradient(90deg, transparent 0%, #b8c5d1 50%, transparent 100%);
}

#filtersResizeHandle::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 4px;
  height: 30px;
  background: repeating-linear-gradient(
    to bottom,
    #6b7280 0px,
    #6b7280 2px,
    transparent 2px,
    transparent 6px
  );
  border-radius: 2px;
}

/* Header */
#filters-panel h3{
  font-weight: 800;
  letter-spacing: .2px;
}
#gf-field-header,
#filters-panel .header-strip{
  background: #e6f3f6;
  border-radius: var(--gf-radius-sm);
  padding: 10px 12px;
}

/* Left list of variables */
#gf-field-list .gf-field-item{
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 12px; border:1px solid var(--gf-border);
  border-radius: 12px; margin-bottom:8px; background:#fff; cursor:pointer;
  transition: transform .05s ease, background .15s ease, border-color .15s ease;
  position:relative;
}
#gf-field-list .gf-field-item:hover{ background:#fafcff; border-color:#d8e3ea; }
#gf-field-list .gf-field-item.active{ background:#eaf6ff; border-color:#b7d9ff; }
#gf-field-list .gf-field-item::before{
  content:""; width:4px; height:70%; border-radius:8px;
  position:absolute; left:6px; top:15%; background: var(--stripe, #7c3aed);
}
#gf-field-list .gf-name{ padding-left:14px; font-weight:600; color:var(--gf-text); }
#gf-field-list .gf-count{
  font-size:.8rem; color:var(--gf-muted); background:#f3f6fa;
  border-radius:999px; padding:2px 8px; border:1px solid var(--gf-border);
}

/* Chips for values */
#gf-chip-wrap{ display:flex; flex-wrap:wrap; gap:10px; }
.gf-chip{
  display:inline-flex; align-items:center; gap:8px;
  padding:8px 12px; border:1px solid var(--chip-border,#dbe7ee);
  border-radius:999px; background: var(--chip-bg,#eef7fb);
  color: var(--chip-fg,#0f3b4a); font-weight:500; cursor:pointer;
  font-size: 13px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: transform .05s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
}
.gf-chip:hover{ 
  transform: translateY(-1px); 
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}
.gf-chip small{ color: var(--gf-muted); font-weight:400; }
.gf-chip.active{
  background: var(--chip-bg-active,#dff3ff);
  border-color: var(--chip-border-active,#b7e2ff);
}

/* Tiny toolbar inputs */
#gf-field-header .form-select, #gf-field-header .form-control{
  border-radius: 12px; border-color: var(--gf-border);
}

/* Selected filters chips */
.gf-selected-chip {
  display: inline-flex; 
  align-items: center; 
  gap: 6px;
  padding: 6px 10px; 
  background: var(--chip-bg, #f0f8ff); 
  border: 1px solid var(--chip-border, #bde0ff);
  border-radius: 16px; 
  font-size: 13px; 
  font-weight: 500;
  color: var(--chip-fg, #1e5a8a);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: all 0.15s ease;
}

.gf-selected-chip:hover {
  background: var(--chip-bg-hover, #e6f3ff);
  border-color: var(--chip-border-hover, #87ceeb);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

.gf-selected-chip-remove {
  background: none;
  border: none;
  color: var(--chip-fg, #1e5a8a);
  cursor: pointer;
  font-size: 16px;
  line-height: 1;
  padding: 0;
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.15s ease;
}

.gf-selected-chip-remove:hover {
  background: rgba(220, 53, 69, 0.1);
  color: #dc3545;
}

.gf-field-name {
  font-weight: 600;
  margin-right: 4px;
}

.gf-constraint-text {
  color: var(--gf-muted, #6b7280);
  font-weight: 400;
}
  </style>

<!-- Global Filters: Backdrop + Panel -->
<div id="filters-backdrop">
  <div id="filters-panel" style="position:relative; max-width:1400px; background:#fff; border-radius:10px; box-shadow:0 12px 40px rgba(0,0,0,.2); padding:16px; max-height:90vh; overflow:auto;">
    <div id="filtersResizeHandle"></div>
    <div style="display:flex; align-items:center; gap:12px; margin-bottom:12px;">
      <h3 style="margin:0; font-weight:700;">Global Filters</h3>
      <div style="margin-left:auto; display:flex; gap:8px;">
        <button id="gf-clear-all" class="btn btn-sm btn-outline-secondary">Clear All</button>
        <button id="gf-cancel" class="btn btn-sm btn-light">Cancel</button>
        <button id="gf-apply" class="btn btn-sm btn-primary">Apply</button>
      </div>
    </div>

    <!-- Selected Filters Chips Bar -->
    <div id="gf-selected-chips" style="display:none; background:var(--gf-soft,#eef6f9); border:1px solid var(--gf-border,#e8ecf0); border-radius:var(--gf-radius-sm,10px); padding:12px; margin-bottom:12px; min-height:20px;">
      <div style="font-size:11px; color:var(--gf-muted,#6b7280); margin-bottom:6px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px;">Active Filters</div>
      <div id="gf-selected-chips-list" style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <span style="color:var(--gf-muted,#6b7280); font-size:14px; font-style:italic;">No filters applied</span>
      </div>
    </div>

    <div style="display:grid; grid-template-columns:260px 1fr; gap:12px; min-height:520px;">
      <!-- Left: groups + fields -->
      <div style="border:1px solid #eee; border-radius:8px; padding:10px;">
        <input id="gf-field-search" placeholder="Search fields…" class="form-control form-control-sm" style="margin-bottom:8px;">
        <div style="font-size:12px; color:#888; margin:6px 0;">Groups</div>
        <div id="gf-groups" style="display:flex; gap:6px; margin-bottom:8px; flex-wrap:wrap;">
          <button data-group="all" class="btn btn-xs btn-outline-secondary active">All</button>
          <button data-group="cat" class="btn btn-xs btn-outline-secondary">Categories</button>
          <button data-group="num" class="btn btn-xs btn-outline-secondary">Numerical</button>
          <button data-group="date" class="btn btn-xs btn-outline-secondary">Dates</button>
        </div>
        <div style="font-size:12px; color:#888; margin:6px 0;">Fields</div>
        <div id="gf-field-list" style="max-height:400px; overflow:auto;"></div>
      </div>

      <!-- Right: value UI -->
      <div style="border:1px solid #eee; border-radius:8px; padding:10px;">
        <div id="gf-field-header" style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">
          <strong id="gf-active-field" style="font-size:14px;">(Select a field)</strong>
          <div style="margin-left:auto; display:flex; gap:8px;">
            <select id="gf-sort" class="form-select form-select-sm" title="Sort">
              <option value="count">Sort by Count</option>
              <option value="az">A → Z</option>
              <option value="za">Z → A</option>
            </select>
            <input id="gf-value-search" class="form-control form-control-sm" placeholder="Search values">
          </div>
        </div>

        <!-- Categorical chips -->
        <div id="gf-chip-wrap" style="display:none; gap:8px; flex-wrap:wrap;"></div>

        <!-- Numerical controls -->
        <div id="gf-num-wrap" style="display:none; gap:12px;">
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
            <label class="form-label form-label-sm" style="margin:0;">Range</label>
            <input id="gf-num-min" type="number" step="any" class="form-control form-control-sm" style="max-width:120px;">
            <span>–</span>
            <input id="gf-num-max" type="number" step="any" class="form-control form-control-sm" style="max-width:120px;">
          </div>
          <input id="gf-num-slider-min" type="range">
          <input id="gf-num-slider-max" type="range">
          <div id="gf-num-bins" style="display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;"></div>
          <div id="gf-num-empty" style="margin-top:6px;"></div>
        </div>

        <!-- Date controls -->
        <div id="gf-date-wrap" style="display:none;">
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
            <select id="gf-date-period" class="form-select form-select-sm" style="max-width:180px;">
              <option value="quarter">Quarters</option>
              <option value="year">Years</option>
              <option value="month">Months</option>
            </select>
            <input id="gf-date-start" type="date" class="form-control form-control-sm">
            <span>→</span>
            <input id="gf-date-end" type="date" class="form-control form-control-sm">
          </div>
          <div id="gf-date-buckets" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
          <div id="gf-date-empty" style="margin-top:6px;"></div>
        </div>

        <div id="gf-help" style="color:#888;">Pick a field on the left to configure its filter.</div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
