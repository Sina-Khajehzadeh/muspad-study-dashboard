<!--
  MUSPAD Dynamic Dashboard (GitHub Pages compatible)

  This HTML file implements an interactive dashboard that loads a CSV
  dataset directly from this GitHub repository and lets users build
  a wide range of charts on the fly.  The layout takes inspiration
  from Polymer's AI dashboard: there is a fixed header with a date‑range
  filter, a vertical sidebar with icons (filters, data table, settings
  and a plus button for adding new charts) and a flexible grid where
  each newly created chart appears as a card.  Users can filter the
  dataset globally by date, age group and employment type, then create
  charts such as bar charts, pie/donut charts, line/time series charts
  and scatter plots.  Each chart updates automatically when global
  filters change.

  Place this file in your repository at: docs/index.html
  Dataset must be at:              docs/data/df3_full_for_pivot.csv

  Note: For GitHub Pages, ensure that all paths are relative to the
  repository root (e.g. data/df3_full_for_pivot.csv).  This version
  disables PapaParse's Web Worker mode to avoid cross‑origin issues.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MUSPAD Dynamic Dashboard</title>

  <!-- Bootstrap CSS and Icons -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-ENjdO4Dr2bkBIFxQpeoGe9CAd1Anb7oh7v1G1roG9LMwHN1fKrbM/8W64HAvK0Pa"
    crossorigin="anonymous"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
  />

  <!-- Plotly.js for charts -->
  <script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      overflow: hidden;
    }
    #app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    /* Sidebar */
    #sidebar {
      width: 50px;
      background-color: #f5f5f5;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 1rem;
    }
    #sidebar button {
      background: none;
      border: none;
      margin-bottom: 1rem;
      font-size: 1.5rem;
      color: #333;
      cursor: pointer;
    }
    #sidebar button:hover {
      color: #007bff;
    }
    /* Main area */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Header */
    #header {
      padding: 0.5rem 1rem;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      background-color: #fff;
    }
    #header h2 {
      margin: 0;
      font-size: 1.5rem;
      flex: 1;
    }
    #header .date-range {
      display: flex;
      gap: 0.5rem;
    }
    #header .date-range input {
      padding: 0.25rem 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    /* Panels (Filters, Data, Settings) */
    .panel {
      display: none;
      background-color: #f9f9f9;
      border-bottom: 1px solid #ddd;
      padding: 1rem;
      overflow-y: auto;
    }
    .panel.active {
      display: block;
    }
    /* Chart grid */
    #chart-container {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .chart-card {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 0.5rem;
      width: calc(50% - 0.5rem);
      min-width: 400px;
      position: relative;
    }
    .chart-card .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }
    .chart-card .card-header h6 {
      margin: 0;
      font-size: 1rem;
    }
    .chart-card .remove-btn {
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 1.2rem;
    }
    .chart-card .remove-btn:hover {
      color: #dc3545;
    }
    /* Chart builder modal */
    #chart-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #chart-modal .modal-content {
      background: #fff;
      padding: 1.5rem;
      border-radius: 6px;
      max-width: 600px;
      width: 90%;
    }
    #chart-modal .form-group {
      margin-bottom: 1rem;
    }
    #chart-modal label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    #chart-modal select,
    #chart-modal input {
      width: 100%;
      padding: 0.35rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #chart-modal .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 1rem;
    }
    @media (max-width: 800px) {
      .chart-card {
        width: 100%;
        min-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <!-- Sidebar -->
    <div id="sidebar">
      <button id="btn-toggle-filter" title="Filters"><i class="bi bi-funnel-fill"></i></button>
      <button id="btn-toggle-data" title="Data Table"><i class="bi bi-table"></i></button>
      <button id="btn-toggle-settings" title="Settings"><i class="bi bi-gear-fill"></i></button>
      <button id="btn-add-chart" title="Add Chart"><i class="bi bi-plus-lg"></i></button>
    </div>
    <!-- Main -->
    <div id="main">
      <!-- Header -->
      <div id="header">
        <h2>MUSPAD Dynamic Dashboard</h2>
        <div class="date-range">
          <input type="date" id="start-date" />
          <input type="date" id="end-date" />
        </div>
      </div>
      <!-- Filter panel -->
      <div id="filter-panel" class="panel">
        <h5>Filters</h5>
        <div class="mb-3">
          <label for="age-select" class="form-label">Age groups</label>
          <select multiple id="age-select" class="form-select"></select>
        </div>
        <div class="mb-3">
          <label for="employment-select" class="form-label">Employment types</label>
          <select multiple id="employment-select" class="form-select"></select>
        </div>
      </div>
      <!-- Data table panel -->
      <div id="data-panel" class="panel">
        <h5>Data Preview</h5>
        <div id="data-table-container"></div>
      </div>
      <!-- Settings panel -->
      <div id="settings-panel" class="panel">
        <h5>Settings</h5>
        <p>You can extend this panel with custom theme or layout options.</p>
      </div>
      <!-- Chart container -->
      <div id="chart-container"></div>
    </div>
  </div>
  <!-- Chart builder modal -->
  <div id="chart-modal">
    <div class="modal-content">
      <h5 class="mb-3">Create Chart</h5>
      <div class="form-group">
        <label for="chart-type">Chart type</label>
        <select id="chart-type" class="form-select">
          <option value="bar">Bar</option>
          <option value="pie">Pie</option>
          <option value="line">Line</option>
          <option value="scatter">Scatter</option>
        </select>
      </div>
      <div class="form-group">
        <label for="x-field">X-axis / Category</label>
        <select id="x-field" class="form-select"></select>
      </div>
      <div class="form-group">
        <label for="y-field">Y-axis (numeric)</label>
        <select id="y-field" class="form-select"></select>
      </div>
      <div class="form-group">
        <label for="color-field">Color / Group (optional)</label>
        <select id="color-field" class="form-select"></select>
      </div>
      <div class="form-group">
        <label for="agg-func">Aggregation</label>
        <select id="agg-func" class="form-select">
          <option value="count">Count</option>
          <option value="sum">Sum</option>
          <option value="mean">Mean</option>
        </select>
      </div>
      <div class="modal-actions">
        <button id="btn-cancel-chart" class="btn btn-secondary">Cancel</button>
        <button id="btn-create-chart" class="btn btn-primary">Create</button>
      </div>
    </div>
  </div>

  <script>
    // Global state
    let rawData = [];
    let filteredData = [];
    let columns = [];
    let charts = [];

    // Entry point
    document.addEventListener('DOMContentLoaded', () => {
      loadData();
      setupSidebar();
    });

    function loadData() {
      // Define possible CSV locations in order of preference.  Use relative
      // paths for GitHub Pages.  Do NOT enable Web Worker (worker: false)
      const urls = [
        'https://cdn.jsdelivr.net/gh/Sina-Khajehzadeh/muspad-study-dashboard/docs/data/df3_full_for_pivot.csv'
      ];

      let i = 0;
      const tryNext = () => {
        if (i >= urls.length) {
          alert('Failed to load CSV from all sources.');
          return;
        }
        const url = urls[i++];
        console.log('Loading data from', url);
        Papa.parse(url, {
          download: true,
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          worker: false,
          transformHeader: (h) => h.replace(/^\uFEFF/, '').trim(),
          complete: function(results) {
            if (!results || !Array.isArray(results.data) || results.data.length === 0) {
              console.warn('Parsed but no rows. Trying next source…');
              tryNext();
              return;
            }
            rawData = results.data;
            columns = (results.meta && Array.isArray(results.meta.fields) && results.meta.fields.length)
              ? results.meta.fields
              : Object.keys(rawData[0] || {});
            console.log('Columns detected:', columns.slice(0, 30));
            initializeFilters();
            initializeChartBuilder();
            applyFiltersAndUpdate();
          },
          error: function(err) {
            console.error('Papa parse error:', err);
            tryNext();
          }
        });
      };
      tryNext();
    }

    function setupSidebar() {
      document.getElementById('btn-toggle-filter').addEventListener('click', () => togglePanel('filter-panel'));
      document.getElementById('btn-toggle-data').addEventListener('click', () => togglePanel('data-panel'));
      document.getElementById('btn-toggle-settings').addEventListener('click', () => togglePanel('settings-panel'));
      document.getElementById('btn-add-chart').addEventListener('click', () => openChartModal());
    }

    function togglePanel(id) {
      const panel = document.getElementById(id);
      panel.classList.toggle('active');
    }

    function initializeFilters() {
      const ageSelect = document.getElementById('age-select');
      const employmentSelect = document.getElementById('employment-select');
      // Column detection lists include dataset specific names as well as generic names
      const possibleAgeCols = [
        'age_group','ageGroup','Age_Group',
        'age_group_22_1','age_group_22_2','age_group_23_1','age_group_23_2'
      ];
      const possibleEmpCols = [
        'employment_type','employmentType','Employment_Type',
        'X20_21_kurzfragen_employment_type_clean','employment_type_clean'
      ];
      const ageCol = possibleAgeCols.find(c => columns.includes(c));
      const empCol = possibleEmpCols.find(c => columns.includes(c));
      // Populate age filter
      if (ageCol) {
        const uniqueAges = [...new Set(rawData.map(r => r[ageCol]))]
          .filter(v => v !== undefined && v !== null && v !== '')
          .sort();
        uniqueAges.forEach(val => {
          const opt = document.createElement('option');
          opt.value = val;
          opt.textContent = val;
          opt.selected = true;
          ageSelect.appendChild(opt);
        });
        ageSelect.dataset.column = ageCol;
      }
      // Populate employment filter
      if (empCol) {
        const uniqueEmps = [...new Set(rawData.map(r => r[empCol]))]
          .filter(v => v !== undefined && v !== null && v !== '')
          .sort();
        uniqueEmps.forEach(val => {
          const opt = document.createElement('option');
          opt.value = val;
          opt.textContent = val;
          opt.selected = true;
          employmentSelect.appendChild(opt);
        });
        employmentSelect.dataset.column = empCol;
      }
      // Date detection: find first column containing parseable dates
      const dateKeys = columns.filter(col => rawData.some(row => row[col] && !isNaN(Date.parse(row[col]))));
      const startDateInput = document.getElementById('start-date');
      const endDateInput = document.getElementById('end-date');
      if (dateKeys.length > 0) {
        const dateCol = dateKeys[0];
        const dates = rawData.map(row => new Date(row[dateCol])).filter(d => !isNaN(d));
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));
        startDateInput.valueAsDate = minDate;
        endDateInput.valueAsDate = maxDate;
        startDateInput.dataset.column = dateCol;
        endDateInput.dataset.column = dateCol;
        startDateInput.min = minDate.toISOString().split('T')[0];
        startDateInput.max = maxDate.toISOString().split('T')[0];
        endDateInput.min = minDate.toISOString().split('T')[0];
        endDateInput.max = maxDate.toISOString().split('T')[0];
      }
      // Event listeners for filters
      ageSelect.addEventListener('change', applyFiltersAndUpdate);
      employmentSelect.addEventListener('change', applyFiltersAndUpdate);
      startDateInput.addEventListener('change', applyFiltersAndUpdate);
      endDateInput.addEventListener('change', applyFiltersAndUpdate);
    }

    function applyFiltersAndUpdate() {
      const startDateInput = document.getElementById('start-date');
      const endDateInput = document.getElementById('end-date');
      const ageSelect = document.getElementById('age-select');
      const empSelect = document.getElementById('employment-select');
      filteredData = rawData.filter(row => {
        let datePass = true;
        if (startDateInput.dataset.column) {
          const dateCol = startDateInput.dataset.column;
          const rowDate = new Date(row[dateCol]);
          const s = startDateInput.value ? new Date(startDateInput.value) : null;
          const e = endDateInput.value ? new Date(endDateInput.value) : null;
          if (s && rowDate < s) datePass = false;
          if (e && rowDate > e) datePass = false;
        }
        let agePass = true;
        if (ageSelect.dataset.column && ageSelect.options.length > 0) {
          const col = ageSelect.dataset.column;
          const selected = Array.from(ageSelect.selectedOptions).map(o => o.value);
          if (selected.length > 0 && !selected.includes(String(row[col]))) agePass = false;
        }
        let empPass = true;
        if (empSelect.dataset.column && empSelect.options.length > 0) {
          const col = empSelect.dataset.column;
          const selected = Array.from(empSelect.selectedOptions).map(o => o.value);
          if (selected.length > 0 && !selected.includes(String(row[col]))) empPass = false;
        }
        return datePass && agePass && empPass;
      });
      // Redraw charts and update data table
      charts.forEach(drawChart);
      updateDataTable();
    }

    function updateDataTable() {
      const container = document.getElementById('data-table-container');
      container.innerHTML = '';
      if (!filteredData || filteredData.length === 0) {
        container.textContent = 'No data to display';
        return;
      }
      const table = document.createElement('table');
      table.className = 'table table-sm table-striped';
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);
      const tbody = document.createElement('tbody');
      const rows = filteredData.slice(0, 100); // limit rows for preview
      rows.forEach(row => {
        const tr = document.createElement('tr');
        columns.forEach(col => {
          const td = document.createElement('td');
          const val = row[col];
          td.textContent = val !== undefined ? val : '';
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);
      container.appendChild(table);
    }

    // Chart builder initialization
    function initializeChartBuilder() {
      const modal = document.getElementById('chart-modal');
      const chartTypeSelect = document.getElementById('chart-type');
      const xFieldSelect = document.getElementById('x-field');
      const yFieldSelect = document.getElementById('y-field');
      const colorSelect = document.getElementById('color-field');
      const aggSelect = document.getElementById('agg-func');
      // Populate select options based on columns
      columns.forEach(col => {
        const optX = document.createElement('option'); optX.value = col; optX.textContent = col; xFieldSelect.appendChild(optX);
        const optY = document.createElement('option'); optY.value = col; optY.textContent = col; yFieldSelect.appendChild(optY);
        const optC = document.createElement('option'); optC.value = col; optC.textContent = col; colorSelect.appendChild(optC);
      });
      // Cancel button
      document.getElementById('btn-cancel-chart').addEventListener('click', () => {
        modal.style.display = 'none';
      });
      // Create button
      document.getElementById('btn-create-chart').addEventListener('click', () => {
        const config = {
          type: chartTypeSelect.value,
          x: xFieldSelect.value,
          y: yFieldSelect.value,
          color: colorSelect.value || null,
          agg: aggSelect.value
        };
        addChart(config);
        modal.style.display = 'none';
      });
    }

    function openChartModal() {
      document.getElementById('chart-modal').style.display = 'flex';
    }

    function addChart(config) {
      charts.push(config);
      createChartCard(config);
      drawChart(config);
    }

    function createChartCard(config) {
      const container = document.getElementById('chart-container');
      const card = document.createElement('div');
      card.className = 'chart-card';
      // Header
      const header = document.createElement('div');
      header.className = 'card-header';
      const title = document.createElement('h6');
      title.textContent = config.type.charAt(0).toUpperCase() + config.type.slice(1) + ' chart';
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.innerHTML = '<i class="bi bi-x"></i>';
      removeBtn.addEventListener('click', () => {
        // Remove from charts array and DOM
        const idx = charts.indexOf(config);
        if (idx > -1) charts.splice(idx, 1);
        container.removeChild(card);
      });
      header.appendChild(title);
      header.appendChild(removeBtn);
      // Chart div
      const chartDiv = document.createElement('div');
      chartDiv.style.height = '300px';
      card.appendChild(header);
      card.appendChild(chartDiv);
      container.appendChild(card);
      config._chartDiv = chartDiv;
    }

    function drawChart(config) {
      const data = filteredData;
      const div = config._chartDiv;
      if (!data || data.length === 0) {
        div.innerHTML = '<p class="text-muted">No data</p>';
        return;
      }
      // Determine aggregator function
      const aggFunc = (values) => {
        if (config.agg === 'sum') {
          return values.reduce((a, b) => (+a || 0) + (+b || 0), 0);
        } else if (config.agg === 'mean') {
          const sum = values.reduce((a, b) => (+a || 0) + (+b || 0), 0);
          return sum / values.length;
        } else {
          // count
          return values.length;
        }
      };
      let fig;
      if (config.type === 'bar' || config.type === 'pie') {
        // Group by X and (optionally) color
        const groups = {};
        data.forEach(row => {
          const key = row[config.x];
          const colorKey = config.color ? row[config.color] : null;
          if (!groups[key]) groups[key] = {};
          if (!groups[key][colorKey]) groups[key][colorKey] = [];
          groups[key][colorKey].push(row[config.y]);
        });
        const labels = Object.keys(groups);
        if (config.type === 'bar') {
          const traces = [];
          const colorKeys = new Set();
          labels.forEach(key => {
            Object.keys(groups[key]).forEach(c => colorKeys.add(c));
          });
          colorKeys.forEach(colorVal => {
            const yVals = labels.map(label => {
              const vals = groups[label][colorVal] || [];
              return aggFunc(vals);
            });
            traces.push({
              x: labels,
              y: yVals,
              name: colorVal || 'Value',
              type: 'bar'
            });
          });
          fig = { data: traces, layout: { barmode: 'group', title: `${config.x} vs ${config.y}` } };
        } else {
          // Pie chart uses only first group; ignore color dimension
          const values = labels.map(label => {
            const vals = [].concat(...Object.values(groups[label]));
            return aggFunc(vals);
          });
          fig = { data: [{ labels: labels, values: values, type: 'pie', hole: 0.3 }], layout: { title: `${config.x} distribution` } };
        }
      } else if (config.type === 'line') {
        // Line chart: group by X (assumed date or numeric) and apply aggregator on Y
        const groups = {};
        data.forEach(row => {
          const key = row[config.x];
          if (!groups[key]) groups[key] = [];
          groups[key].push(row[config.y]);
        });
        const xVals = Object.keys(groups).sort((a, b) => {
          // Sort by date or numeric if possible
          const da = new Date(a); const db = new Date(b);
          if (!isNaN(da) && !isNaN(db)) return da - db;
          if (!isNaN(Number(a)) && !isNaN(Number(b))) return a - b;
          return String(a).localeCompare(String(b));
        });
        const yVals = xVals.map(k => aggFunc(groups[k]));
        fig = { data: [{ x: xVals, y: yVals, type: 'scatter', mode: 'lines+markers' }], layout: { title: `${config.x} vs ${config.y}` } };
      } else if (config.type === 'scatter') {
        // Scatter plot: raw data points; color optional
        const trace = {
          x: data.map(r => r[config.x]),
          y: data.map(r => r[config.y]),
          mode: 'markers',
          type: 'scatter',
        };
        if (config.color) {
          trace.marker = { color: data.map(r => r[config.color]), colorscale: 'Viridis', showscale: true };
        }
        fig = { data: [trace], layout: { title: `${config.x} vs ${config.y}`, xaxis: { title: config.x }, yaxis: { title: config.y } } };
      }
      Plotly.newPlot(div, fig.data, fig.layout, { responsive: true });
    }
  </script>
</body>
</html>
