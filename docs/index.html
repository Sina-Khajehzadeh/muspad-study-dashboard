<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MUSPAD Dynamic Dashboard</title>

  <!-- Bootstrap (lightweight layout & utilities) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <!-- Plotly + PapaParse -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Tiny inline favicon -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%230d6efd'/%3E%3Ctext x='50%25' y='54%25' font-size='42' text-anchor='middle' fill='white'%3EM%3C/text%3E%3C/svg%3E"/>

  <style>
    :root { --sidebar-w: 56px; --card-min: 380px; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; overflow:hidden; background:#fff; }
    #app { display:flex; height:100vh; overflow:hidden; }

    /* Sidebar */
    #sidebar {
      width: var(--sidebar-w);
      background:#f7f7f8; border-right:1px solid #e9ecef;
      display:flex; flex-direction:column; align-items:center; gap:.5rem; padding:.5rem .25rem;
    }
    #sidebar button {
      width:36px; height:36px; border:0; background:transparent; border-radius:8px;
      display:grid; place-items:center; font-size:1.25rem; color:#334155; cursor:pointer;
    }
    #sidebar button:hover { background:#eceff3; color:#0d6efd; }
    #sidebar .sep { width:24px; height:1px; background:#e2e8f0; margin:.25rem 0; }

    /* Main */
    #main { flex:1; display:flex; flex-direction:column; min-width:0; overflow:hidden; }
    #header {
      display:flex; align-items:center; gap:.75rem; padding:.5rem 1rem;
      border-bottom:1px solid #e9ecef; background:#fff;
    }
    #title { margin:0; font-weight:600; font-size:1.1rem; }
    .header-spacer { flex:1; }
    #status { color:#64748b; font-size:.9rem; }
    .date-range { display:flex; gap:.5rem; align-items:center; }

    /* Panels */
    .panel { display:none; background:#f8f9fa; border-bottom:1px solid #e9ecef; padding:.75rem 1rem; overflow:auto; }
    .panel.active { display:block; }
    .panel h6 { margin-bottom:.5rem; font-weight:600; }

    /* Grid */
    #grid { flex:1; overflow:auto; padding:1rem; display:flex; flex-wrap:wrap; gap:1rem; }
    .card-chart {
      width: calc(50% - .5rem); min-width: var(--card-min); background:#fff;
      border:1px solid #e9ecef; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,.03);
    }
    .card-chart .card-header {
      display:flex; align-items:center; justify-content:space-between;
      padding:.5rem .75rem; border-bottom:1px solid #eef1f4;
    }
    .card-chart .plot { height:320px; padding:.5rem; }
    .remove { border:0; background:transparent; color:#64748b; }
    .remove:hover { color:#dc3545; }

    @media (max-width: 900px) {
      .card-chart { width:100%; min-width:100%; }
    }

    /* Modal */
    #modal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.45); z-index:1000; padding:1rem; }
    #modal .sheet { width:min(720px, 100%); background:#fff; border-radius:12px; padding:1rem 1rem 1.25rem; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    #modal .grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:.75rem; }
    #modal .actions { display:flex; justify-content:flex-end; gap:.5rem; margin-top:.75rem; }
    @media (max-width: 680px) { #modal .grid { grid-template-columns: 1fr; } }

    .muted { color:#94a3b8; }
    .chip { display:inline-flex; align-items:center; gap:.25rem; background:#eef2ff; color:#3730a3; border-radius:16px; padding:.125rem .5rem; font-size:.8rem; }
  </style>
</head>
<body>
<div id="app">
  <!-- Sidebar -->
  <aside id="sidebar" aria-label="Toolbar">
    <button id="btnAdd" title="Add chart" aria-label="Add chart"><i class="bi bi-plus-lg"></i></button>
    <button id="btnFilters" title="Filters" aria-label="Filters"><i class="bi bi-funnel-fill"></i></button>
    <button id="btnData" title="Data table" aria-label="Data"><i class="bi bi-table"></i></button>
    <div class="sep"></div>
    <button id="btnSettings" title="Settings" aria-label="Settings"><i class="bi bi-gear-fill"></i></button>
  </aside>

  <!-- Main -->
  <main id="main">
    <!-- Header -->
    <header id="header">
      <h1 id="title">MUSPAD Dynamic Dashboard</h1>
      <span id="status" aria-live="polite" class="ms-1"></span>
      <div class="header-spacer"></div>

      <!-- File upload (optional) -->
      <label class="btn btn-outline-secondary btn-sm mb-0">
        <i class="bi bi-upload"></i> Upload CSV
        <input id="fileInput" type="file" accept=".csv" hidden>
      </label>

      <!-- Date range -->
      <div class="date-range">
        <span class="muted">Date:</span>
        <input type="date" id="startDate" aria-label="Start date">
        <input type="date" id="endDate" aria-label="End date">
        <span id="activeRange" class="chip" title="Active date range"></span>
      </div>
    </header>

    <!-- Filter panel -->
    <section id="panelFilters" class="panel" aria-label="Filters">
      <h6>Filters</h6>
      <p class="text-muted mb-2">Columns are auto-classified into <strong>categorical</strong>, <strong>numeric</strong>, and <strong>date</strong>. Adjust to filter charts globally.</p>

      <div id="filtersRoot" class="row g-3">
        <!-- Dynamic filter controls injected here -->
      </div>
    </section>

    <!-- Data panel -->
    <section id="panelData" class="panel active" aria-label="Data preview">
      <div class="d-flex align-items-center justify-content-between">
        <h6 class="mb-2">Data Preview</h6>
        <div class="muted" id="shapeBadge"></div>
      </div>
      <div class="table-responsive" id="tableWrap"></div>
    </section>

    <!-- Settings panel -->
    <section id="panelSettings" class="panel" aria-label="Settings">
      <h6>Settings</h6>
      <div class="row g-3">
        <div class="col-sm-6">
          <label class="form-label">Theme</label>
          <select id="themeSelect" class="form-select form-select-sm">
            <option value="light" selected>Light</option>
            <option value="dark">Dark</option>
          </select>
        </div>
        <div class="col-sm-6">
          <label class="form-label">Chart height (px)</label>
          <input id="chartHeight" type="number" class="form-control form-control-sm" value="320" min="220" max="800">
        </div>
      </div>
      <p class="text-muted mt-2 mb-0">More settings can be added here (color palette, font, legend, etc.).</p>
    </section>

    <!-- Chart grid -->
    <section id="grid" aria-label="Charts"></section>
  </main>
</div>

<!-- Chart Builder Modal -->
<div id="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div class="sheet">
    <h5 id="modalTitle" class="mb-3">Create chart</h5>
    <div class="grid">
      <div>
        <label class="form-label">Chart type</label>
        <select id="fldType" class="form-select">
          <option value="bar">Column / Bar</option>
          <option value="barline">Bar + Line</option>
          <option value="pie">Pie / Donut</option>
          <option value="line">Time Series / Line</option>
          <option value="scatter">Scatter</option>
          <option value="bubble">Bubble</option>
          <option value="box">Box Plot</option>
          <option value="heatmap">Heatmap</option>
          <option value="funnel">Funnel</option>
          <option value="table">Data Table</option>
          <option value="pivot">Pivot Table</option>
          <!-- combo examples -->
          <option value="box+hist">Box + Histogram</option>
          <option value="line+hist">Line + Histogram</option>
        </select>
      </div>
      <div>
        <label class="form-label">X / Category</label>
        <select id="fldX" class="form-select"></select>
      </div>
      <div>
        <label class="form-label">Y (numeric)</label>
        <select id="fldY" class="form-select"></select>
      </div>
      <div>
        <label class="form-label">Color / Group (optional)</label>
        <select id="fldColor" class="form-select"></select>
      </div>
      <div>
        <label class="form-label">Aggregation</label>
        <select id="fldAgg" class="form-select">
          <option value="count">Count</option>
          <option value="sum">Sum</option>
          <option value="mean" selected>Mean</option>
          <option value="median">Median</option>
        </select>
      </div>
      <div>
        <label class="form-label">Donut (pie only)</label>
        <select id="fldDonut" class="form-select">
          <option value="0">Pie</option>
          <option value="0.4" selected>Donut</option>
        </select>
      </div>
    </div>
    <div class="actions">
      <button id="btnCancel" class="btn btn-outline-secondary">Cancel</button>
      <button id="btnCreate" class="btn btn-primary">Create</button>
    </div>
  </div>
</div>

<script>
/* ======================
   Global state
====================== */
let rawData = [];         // all rows
let filtered = [];        // filtered rows
let columns = [];         // column names
let charts = [];          // chart cfgs
let types = { cat:[], num:[], date:[] };
let primaryDate = null;

const CSV_FALLBACKS = [
  'data/df3_full_for_pivot.csv',
  'https://sina-khajehzadeh.github.io/muspad-study-dashboard/data/df3_full_for_pivot.csv',
  'https://raw.githubusercontent.com/Sina-Khajehzadeh/muspad-study-dashboard/main/docs/data/df3_full_for_pivot.csv',
  'https://cdn.jsdelivr.net/gh/Sina-Khajehzadeh/muspad-study-dashboard/docs/data/df3_full_for_pivot.csv'
];

/* ======================
   Boot
====================== */
document.addEventListener('DOMContentLoaded', () => {
  wireUI();
  loadCSV();
});

function wireUI(){
  // Sidebar
  on('btnAdd','click', openModal);
  on('btnFilters','click', () => togglePanel('panelFilters'));
  on('btnData','click', () => togglePanel('panelData'));
  on('btnSettings','click', () => togglePanel('panelSettings'));

  // Header inputs
  on('startDate','change', applyFilters);
  on('endDate','change', applyFilters);

  // Modal
  on('btnCancel','click', closeModal);
  on('btnCreate','click', () => { addChartFromModal(); closeModal(); });
  byId('modal').addEventListener('click', (e)=>{ if(e.target===byId('modal')) closeModal(); });

  // Upload
  on('fileInput','change', (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    parseCSVFile(file);
  });

  // Theme / settings
  on('themeSelect','change', applyTheme);
  on('chartHeight','input', () => { charts.forEach(drawChart); });

  applyTheme();
}

/* ======================
   CSV loading
====================== */
function loadCSV(){
  let i=0;
  const next = () => {
    if (i>=CSV_FALLBACKS.length) { setStatus('Failed to load CSV'); alert('Failed to load CSV from all sources.'); return; }
    const url = CSV_FALLBACKS[i++];
    parseCSVUrl(url, next);
  };
  next();
}

function parseCSVUrl(url, onFail){
  setStatus(`Loading: ${url}`);
  Papa.parse(url, {
    download: true, header: true, skipEmptyLines: true, dynamicTyping: true,
    transformHeader: (h)=>(h||'').replace(/^\uFEFF/,'').trim(),
    complete: (res)=>{
      if (!res?.data?.length) { onFail?.(); return; }
      ingest(res.data, res.meta?.fields);
    },
    error: (err)=>{ console.warn('Papa error:', err); onFail?.(); }
  });
}

function parseCSVFile(file){
  setStatus(`Parsing: ${file.name}`);
  Papa.parse(file, {
    header: true, skipEmptyLines: true, dynamicTyping: true,
    transformHeader: (h)=>(h||'').replace(/^\uFEFF/,'').trim(),
    complete: (res)=>{
      if (!res?.data?.length) { alert('Empty CSV file.'); return; }
      ingest(res.data, res.meta?.fields);
    },
    error: (err)=>{ alert('Parse error: ' + err?.message); }
  });
}

function ingest(rows, fields){
  rawData = rows;
  columns = fields?.length ? fields : Object.keys(rows[0]||{});
  setStatus(`Loaded ${rows.length.toLocaleString()} rows • ${columns.length} cols`);
  detectTypes();
  buildFilterPanel();
  populateBuilderSelects();
  initDateRangeDefaults();
  applyFilters();
  autoStarterCharts();
  updateTable();
}

/* ======================
   Type detection
====================== */
function detectTypes(){
  const isMostlyNums = (col)=>{
    const vals = sample(col, 300);
    let c=0; for (const v of vals) if (typeof v==='number' && !Number.isNaN(v)) c++;
    return vals.length ? (c/vals.length)>=0.7 : false;
  };
  const isDateCol = (col)=>{
    const vals = sample(col, 300);
    let parsed=0, inRange=0;
    for (const v of vals){
      const d = new Date(v);
      if (!isNaN(d)){ parsed++; const y=d.getUTCFullYear(); if (y>=1990 && y<=2100) inRange++; }
    }
    const rate = vals.length ? parsed/vals.length : 0;
    return rate>=0.7 && (inRange/Math.max(1,vals.length))>=0.6;
  };

  const cat=[], num=[], date=[];
  for (const c of columns){
    if (isDateCol(c)) date.push(c);
    else if (isMostlyNums(c)) num.push(c);
    else cat.push(c);
  }
  types = { cat, num, date };
  // choose primary date if available, prefer names with 'date' or 'time'
  primaryDate = date.sort((a,b)=>{
    const sa = /(date|time|timestamp)/i.test(a) ? 1 : 0;
    const sb = /(date|time|timestamp)/i.test(b) ? 1 : 0;
    return sb - sa;
  })[0] || null;
}

/* ======================
   Filters UI
====================== */
function buildFilterPanel(){
  const root = byId('filtersRoot');
  root.innerHTML = '';

  // Categorical
  const colCat = el('div',{class:'col-md-6'});
  colCat.append(el('label',{class:'form-label fw-semibold'},'Categorical'));
  const catWrap = el('div',{class:'vstack gap-2'});
  for (const c of types.cat.slice(0,30)){   // cap to prevent huge UI
    const values = uniqNonEmpty(rawData.map(r=>r[c]));
    const sel = el('select',{class:'form-select form-select-sm', multiple:true, size: Math.min(6, Math.max(3, values.length))});
    sel.dataset.type='cat'; sel.dataset.col=c;
    values.forEach(v=> sel.append(el('option',{value:String(v)}, String(v))));
    const row = el('div',{class:'d-flex align-items-start gap-2'},
      el('div',{class:'small fw-semibold', style:'width: 38%'}, c),
      el('div',{class:'flex-grow-1'}, sel),
      el('div',{class:'d-flex flex-column gap-1'},
        button('Select all','btn btn-outline-secondary btn-sm', ()=>{ for (const o of sel.options) o.selected=true; applyFilters(); }),
        button('Clear','btn btn-outline-secondary btn-sm', ()=>{ for (const o of sel.options) o.selected=false; applyFilters(); })
      )
    );
    catWrap.append(row);
  }
  colCat.append(catWrap);
  root.append(colCat);

  // Numeric
  const colNum = el('div',{class:'col-md-6'});
  colNum.append(el('label',{class:'form-label fw-semibold'},'Numeric'));
  const numWrap = el('div',{class:'vstack gap-2'});
  for (const c of types.num.slice(0,30)){
    const vals = rawData.map(r=>+r[c]).filter(v=>!Number.isNaN(v)).sort((a,b)=>a-b);
    const min = vals.length ? vals[0] : '';
    const max = vals.length ? vals[vals.length-1] : '';
    const minI = el('input',{class:'form-control form-control-sm', type:'number', step:'any', value:min});
    const maxI = el('input',{class:'form-control form-control-sm', type:'number', step:'any', value:max});
    for (const x of [minI,maxI]) { x.dataset.type='num'; x.dataset.col=c; x.addEventListener('change', applyFilters); }
    const row = el('div',{class:'row g-2 align-items-center'},
      el('div',{class:'col-4 small fw-semibold'}, c),
      el('div',{class:'col-4'}, minI),
      el('div',{class:'col-4'}, maxI),
    );
    numWrap.append(row);
  }
  colNum.append(numWrap);
  root.append(colNum);

  // Date (header date picker already present; list other date cols for info)
  if (types.date.length){
    const info = el('div',{class:'col-12 mt-2 text-muted small'}, `Detected date columns: ${types.date.join(', ')}`);
    root.append(info);
  }
}

function initDateRangeDefaults(){
  if (!primaryDate) { byId('startDate').value=''; byId('endDate').value=''; byId('activeRange').textContent=''; return; }
  const ds = rawData.map(r=> new Date(r[primaryDate])).filter(d=>!isNaN(d)).sort((a,b)=>a-b);
  if (!ds.length) return;

  // default to 2020-01-01 .. 2024-12-31 if within bounds; otherwise use full span
  const prefStart = new Date('2020-01-01');
  const prefEnd   = new Date('2024-12-31');
  const minD = ds[0], maxD = ds[ds.length-1];

  const start = (prefStart>=minD && prefStart<=maxD) ? prefStart : minD;
  const end   = (prefEnd>=minD && prefEnd<=maxD) ? prefEnd : maxD;

  const minISO = toISO(minD), maxISO = toISO(maxD);
  byId('startDate').min=minISO; byId('startDate').max=maxISO;
  byId('endDate').min=minISO;   byId('endDate').max=maxISO;

  byId('startDate').value = toISO(start);
  byId('endDate').value   = toISO(end);
  byId('activeRange').textContent = `${toISO(start)} → ${toISO(end)}`;
}

/* ======================
   Filtering
====================== */
function applyFilters(){
  // Build filter config from UI
  const cfg = { cats:{}, nums:{}, date:null };

  // categorical
  for (const sel of bySelAll('#filtersRoot select[data-type="cat"]')){
    const col = sel.dataset.col;
    const values = Array.from(sel.selectedOptions).map(o=>o.value);
    if (values.length) cfg.cats[col] = new Set(values.map(String));
  }
  // numeric min/max
  for (const inp of bySelAll('#filtersRoot input[data-type="num"]')){
    const col = inp.dataset.col;
    const v = inp.value==='' ? null : +inp.value;
    if (!cfg.nums[col]) cfg.nums[col] = {min:null,max:null};
    if (inp === inp.parentElement?.parentElement?.querySelector('input[data-type="num"]')) {
      // left input is min (but simpler to detect via position); handle below together
    }
  }
  // pair mins/maxes properly
  const rows = bySelAll('#filtersRoot .row.g-2');
  for (const r of rows){
    const col = r.querySelector('div.col-4.small.fw-semibold')?.textContent?.trim();
    if (!col) continue;
    const [minI, maxI] = r.querySelectorAll('input[data-type="num"]');
    if (!minI || !maxI) continue;
    const min = minI.value===''?null:+minI.value;
    const max = maxI.value===''?null:+maxI.value;
    cfg.nums[col] = {min, max};
  }

  // date range
  if (primaryDate){
    const sVal = byId('startDate').value;
    const eVal = byId('endDate').value;
    cfg.date = {
      col: primaryDate,
      start: sVal ? new Date(sVal) : null,
      end:   eVal ? new Date(eVal) : null
    };
    byId('activeRange').textContent = (cfg.date.start && cfg.date.end)
      ? `${toISO(cfg.date.start)} → ${toISO(cfg.date.end)}`
      : '';
  }

  // apply
  filtered = rawData.filter(r=>{
    // cats
    for (const [col,setv] of Object.entries(cfg.cats)){
      const val = (r[col]===null||r[col]===undefined)? '' : String(r[col]);
      if (!setv.has(val)) return false;
    }
    // nums
    for (const [col,b] of Object.entries(cfg.nums)){
      const val = +r[col];
      if (!Number.isFinite(val)) continue;
      if (b.min!==null && val < b.min) return false;
      if (b.max!==null && val > b.max) return false;
    }
    // date
    if (cfg.date && cfg.date.start && cfg.date.end){
      const d = new Date(r[cfg.date.col]);
      if (isNaN(d) || d < cfg.date.start || d > cfg.date.end) return false;
    }
    return true;
  });

  updateTable();
  charts.forEach(drawChart);
}

/* ======================
   Data table
====================== */
function updateTable(){
  const wrap = byId('tableWrap');
  byId('shapeBadge').textContent = `${filtered.length.toLocaleString()} rows × ${columns.length} cols`;
  wrap.innerHTML = '';
  if (!filtered.length){ wrap.innerHTML = '<div class="text-muted">No data to display</div>'; return; }

  const table = el('table',{class:'table table-sm table-striped align-middle'});
  const thead = el('thead',{}, el('tr',{}, ...columns.map(c=>el('th',{}, c))));
  const tbody = el('tbody');
  const rows = filtered.slice(0,150);
  for (const r of rows){
    tbody.append(el('tr',{}, ...columns.map(c=> el('td',{}, (r[c]??'')+''))));
  }
  table.append(thead, tbody);
  wrap.append(table);
}

/* ======================
   Add Charts
====================== */
function populateBuilderSelects(){
  const xSel = byId('fldX'), ySel = byId('fldY'), cSel = byId('fldColor');
  for (const s of [xSel,ySel,cSel]) s.innerHTML='';
  // X/categories: prefer categorical + dates; Y: numeric; Color: cats first then numeric
  [...types.cat, ...types.date, ...types.num].forEach(c=> xSel.append(option(c)));
  [...types.num, ...types.cat].forEach(c=> ySel.append(option(c)));
  [...types.cat, ...types.num].forEach(c=> cSel.append(option(c)));
}

function addChartFromModal(){
  const cfg = {
    type: byId('fldType').value,
    x: byId('fldX').value || null,
    y: byId('fldY').value || null,
    color: byId('fldColor').value || null,
    agg: byId('fldAgg').value || 'mean',
    donut: parseFloat(byId('fldDonut').value||'0'),
    height: +byId('chartHeight').value || 320
  };
  addChart(cfg);
}

function addChart(cfg){
  charts.push(cfg);
  const card = el('div',{class:'card-chart'});
  card.innerHTML = `
    <div class="card-header">
      <div class="small fw-semibold">${titleFor(cfg)}</div>
      <button class="remove" title="Remove"><i class="bi bi-x-lg"></i></button>
    </div>
    <div class="plot"></div>`;
  byId('grid').append(card);
  cfg._el = card.querySelector('.plot');
  card.querySelector('.remove').addEventListener('click', ()=>{
    charts = charts.filter(c=>c!==cfg); card.remove();
  });
  drawChart(cfg);
}

function titleFor(cfg){
  const pretty = {
    'bar':'Bar','barline':'Bar+Line','pie':'Pie/Donut','line':'Line',
    'scatter':'Scatter','bubble':'Bubble','box':'Box Plot','heatmap':'Heatmap',
    'funnel':'Funnel','table':'Data Table','pivot':'Pivot Table','box+hist':'Box+Hist','line+hist':'Line+Hist'
  }[cfg.type] || cfg.type;
  const parts=[pretty];
  if (cfg.x) parts.push(`X: ${cfg.x}`);
  if (cfg.y && cfg.agg) parts.push(`Y: ${cfg.agg}(${cfg.y})`);
  if (cfg.color) parts.push(`Color: ${cfg.color}`);
  return parts.join(' · ');
}

/* ======================
   Chart renderers (modular)
====================== */
function drawChart(cfg){
  const el = cfg._el;
  if (!filtered.length){ el.innerHTML='<div class="text-muted p-2">No data</div>'; return; }
  const H = cfg.height || 320;
  let fig = { data:[], layout:{ margin:{l:50,r:20,b:50,t:40}, height:H, hovermode:'closest' } };

  // common utilities
  const groupBy = (rows, keys)=>{
    const m=new Map();
    for (const r of rows){
      const k = keys.map(k=> String(r[k])).join('¦');
      if(!m.has(k)) m.set(k, []);
      m.get(k).push(r);
    }
    return { map:m, keys };
  };
  const aggregate = (rows, col, mode)=>{
    if (mode==='count') return rows.length;
    const vals = rows.map(r=>+r[col]).filter(v=>Number.isFinite(v));
    if (!vals.length) return 0;
    if (mode==='sum') return vals.reduce((a,b)=>a+b,0);
    if (mode==='median'){
      const s=vals.slice().sort((a,b)=>a-b); const mid=Math.floor(s.length/2);
      return s.length%2 ? s[mid] : (s[mid-1]+s[mid])/2;
    }
    // mean default
    return vals.reduce((a,b)=>a+b,0)/vals.length;
  };

  // per type
  if (cfg.type==='bar' || cfg.type==='barline' || cfg.type==='pie'){
    // group by X and optional color
    const useColor = cfg.color && columns.includes(cfg.color);
    const by = useColor ? [cfg.x, cfg.color] : [cfg.x];
    const g = groupBy(filtered, by);
    const xs = Array.from(new Set(Array.from(g.map.keys()).map(k=>k.split('¦')[0])));
    const colors = useColor ? Array.from(new Set(Array.from(g.map.keys()).map(k=>k.split('¦')[1]))) : [null];

    if (cfg.type==='pie'){
      const values = xs.map(xv=>{
        const rows = Array.from(g.map.entries()).filter(([k])=>k.split('¦')[0]===String(xv)).flatMap(([,v])=>v);
        return aggregate(rows, cfg.y||cfg.x, cfg.agg||'count');
      });
      fig.data.push({ labels: xs, values, type:'pie', hole: cfg.donut||0 });
      fig.layout.title = titleFor(cfg);
    } else {
      // bar or bar+line
      for (const c of colors){
        const y = xs.map(xv=>{
          const key = useColor ? [xv,c].join('¦') : String(xv);
          return aggregate(g.map.get(key)||[], cfg.y, cfg.agg);
        });
        fig.data.push({ x: xs, y, type:'bar', name: c ?? 'value' });
      }
      fig.layout.barmode='group';
      fig.layout.xaxis={ title: cfg.x };
      if (cfg.y) fig.layout.yaxis={ title: `${cfg.agg}(${cfg.y})` };

      if (cfg.type==='barline'){
        // overlay mean line across bars (simple example)
        const allY = fig.data.reduce((acc,tr)=>acc.map((v,i)=>v+(tr.y[i]||0)), Array(fig.data[0].y.length).fill(0));
        const meanY = allY.map(v=> v/fig.data.length);
        fig.data.push({ x: xs, y: meanY, type:'scatter', mode:'lines+markers', name:'Line' });
      }
    }
  }
  else if (cfg.type==='line' || cfg.type==='line+hist'){
    const g = groupBy(filtered, [cfg.x]);
    const xs = Array.from(g.map.keys()).map(k=>k.split('¦')[0]);
    const sortedX = xs.slice().sort((a,b)=>{
      const da = new Date(a), db = new Date(b);
      if (!isNaN(da) && !isNaN(db)) return da - db;
      const na=+a, nb=+b; if (Number.isFinite(na)&&Number.isFinite(nb)) return na-nb;
      return String(a).localeCompare(String(b));
    });
    const y = sortedX.map(xv => aggregate(g.map.get(String(xv))||[], cfg.y, cfg.agg));
    fig.data.push({ x: sortedX, y, type:'scatter', mode:'lines+markers', name:'Line' });
    fig.layout.xaxis = { title: cfg.x };
    fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };
    if (cfg.type==='line+hist'){
      fig.data.push({ x: y, type:'histogram', opacity:.35, xaxis:'x2', yaxis:'y2', name:'Hist' });
      fig.layout.grid = { rows:1, columns:2, subplots:[['xy','xy2']], pattern:'independent' };
    }
  }
  else if (cfg.type==='scatter' || cfg.type==='bubble'){
    const x = filtered.map(r=>r[cfg.x]);
    const y = filtered.map(r=>r[cfg.y]);
    const color = cfg.color && columns.includes(cfg.color) ? filtered.map(r=>r[cfg.color]) : null;

    if (cfg.type==='bubble'){
      const sizeCol = cfg.y; // simple default: size by Y
      const size = filtered.map(r=> Math.max(6, Math.min(40, Math.abs(+r[sizeCol]) || 6)));
      fig.data.push({ x, y, mode:'markers', type:'scatter', marker:{ size, color, showscale: !!color }, name:'Bubble' });
    } else {
      if (color && !looksNumericColumn(cfg.color)){
        const cats = uniqNonEmpty(color).slice(0,15);
        for (const c of cats){
          const pts = filtered.filter(r=> String(r[cfg.color])===String(c));
          fig.data.push({ x: pts.map(r=>r[cfg.x]), y: pts.map(r=>r[cfg.y]), mode:'markers', type:'scatter', name:c });
        }
      } else {
        fig.data.push({ x, y, mode:'markers', type:'scatter', marker:{ color, showscale: !!(color && looksNumericColumn(cfg.color)) } });
      }
    }
    fig.layout.xaxis={ title: cfg.x }; fig.layout.yaxis={ title: cfg.y };
  }
  else if (cfg.type==='box'){
    const x = cfg.color && columns.includes(cfg.color) ? cfg.color : cfg.x;
    const g = groupBy(filtered, [x]);
    for (const key of g.map.keys()){
      const ys = (g.map.get(key)||[]).map(r=> +r[cfg.y]).filter(Number.isFinite);
      fig.data.push({ y: ys, name: key.split('¦')[0], type:'box', boxmean:true });
    }
    fig.layout.yaxis = { title: cfg.y };
  }
  else if (cfg.type==='heatmap'){
    // Simple 2D count heatmap for X(cat/num) vs Y(cat/num)
    const xVals = uniqNonEmpty(filtered.map(r=>r[cfg.x]));
    const yVals = uniqNonEmpty(filtered.map(r=>r[cfg.y]));
    const z = yVals.map(()=> Array(xVals.length).fill(0));
    for (const r of filtered){
      const xi = xVals.indexOf(String(r[cfg.x]));
      const yi = yVals.indexOf(String(r[cfg.y]));
      if (xi>=0 && yi>=0) z[yi][xi] += 1;
    }
    fig.data.push({ z, x: xVals, y: yVals, type:'heatmap', colorscale:'Blues' });
    fig.layout.xaxis={ title: cfg.x }; fig.layout.yaxis={ title: cfg.y };
  }
  else if (cfg.type==='funnel'){
    // Expect X as stage (cat) and Y numeric (sum/mean)
    const g = new Map();
    for (const r of filtered){
      const k = String(r[cfg.x]); if (!g.has(k)) g.set(k, []);
      g.get(k).push(r);
    }
    const stages = Array.from(g.keys());
    const vals = stages.map(s => aggregate(g.get(s), cfg.y, cfg.agg));
    fig.data.push({ type:'funnel', y: stages, x: vals });
  }
  else if (cfg.type==='table'){
    // Just render the first 250 rows of filtered as a Plotly table
    const head = columns;
    const colData = columns.map(c => filtered.slice(0,250).map(r => r[c]));
    fig.data.push({ type:'table', header:{ values: head, align:'left' }, cells:{ values: colData, align:'left' } });
    fig.layout.margin = {l:10, r:10, b:10, t:30};
  }
  else if (cfg.type==='pivot'){
    el.innerHTML = '<div class="p-3 text-muted">Pivot table: implement with your rules (groupby/agg → table). Placeholder here.</div>';
    return;
  }
  else if (cfg.type==='box+hist'){
    el.innerHTML = '<div class="p-3 text-muted">Combo plot (Box+Hist) placeholder. Add your preferred composition here.</div>';
    return;
  }
  else {
    el.innerHTML = '<div class="p-3 text-muted">Chart type not implemented (yet).</div>';
    return;
  }

  Plotly.newPlot(el, fig.data, fig.layout, {responsive:true, displaylogo:false});
}

/* ======================
   Starter charts
====================== */
function autoStarterCharts(){
  // Simple heuristics
  const num = types.num[0], num2 = types.num[1] || types.num[0];
  const cat = types.cat.find(c=>/age|group/i.test(c)) || types.cat[0];
  if (cat) addChart({ type:'bar', x:cat, y:num||cat, agg:'mean', height: +byId('chartHeight').value });
  if (primaryDate && num) addChart({ type:'line', x:primaryDate, y:num, agg:'mean', height:+byId('chartHeight').value });
  if (types.cat.length) addChart({ type:'pie', x:types.cat[0], y:num||types.cat[0], agg:'count', donut:0.4, height:+byId('chartHeight').value });
}

/* ======================
   Theme
====================== */
function applyTheme(){
  const t = byId('themeSelect').value;
  document.documentElement.dataset.theme = t;
  // Light/dark tweak: invert grid background (simple example)
  document.body.style.background = (t==='dark') ? '#0b1220' : '#fff';
}

/* ======================
   Utilities
====================== */
const byId = (s)=>document.getElementById(s);
const on = (id,ev,fn)=> byId(id).addEventListener(ev,fn);
const bySelAll = (q)=> Array.from(document.querySelectorAll(q));
const el = (tag, attrs={}, ...kids)=>{
  const n = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs||{})){ if (k==='class') n.className=v; else n.setAttribute(k,v); }
  for (const k of kids){ if (k==null) continue; n.append(typeof k==='string'? document.createTextNode(k):k); }
  return n;
};
const button = (txt, cls, onClick)=> { const b=el('button',{class:cls, type:'button'},txt); b.addEventListener('click', onClick); return b; };
const option = (v, label)=> { const o=document.createElement('option'); o.value=v; o.textContent=label??v; return o; };
const uniqNonEmpty = (arr)=> Array.from(new Set(arr.map(v => (v==null?'':String(v))).filter(s=>s!==''))).sort();
const sample = (col, n=200)=>{
  const out=[]; const step=Math.max(1, Math.floor(rawData.length / n));
  for (let i=0;i<rawData.length;i+=step){ const v=rawData[i]?.[col]; if (v!==undefined && v!==null && v!=='') out.push(v); if (out.length>=n) break; }
  return out;
};
const looksNumericColumn = (col)=>{
  const vals = sample(col, 160);
  if (!vals.length) return false;
  let nums=0; for (const v of vals) if (typeof v==='number' && !Number.isNaN(v)) nums++;
  return nums/vals.length >= 0.7;
};
const toISO = (d)=> new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().split('T')[0];
function togglePanel(id){ byId(id).classList.toggle('active'); }
function openModal(){ byId('modal').style.display='grid'; }
function closeModal(){ byId('modal').style.display='none'; }
function setStatus(txt){ byId('status').textContent = txt||''; }
</script>
</body>
</html>
