<!--
  MUSPAD Dynamic Dashboard (GitHub Pages compatible)
  Place this file at: docs/index.html
  CSV expected at:    docs/data/df3_full_for_pivot.csv

  Key fixes & polish:
  - Robust date detection (name hint + parse rate + year range).
  - Employment column list includes: X20_21_langfragen_employment_type_clean.
  - No default date filtering (inputs blank by default).
  - Data panel opens automatically; starter charts added after load.
  - Multiple CSV fallbacks: relative, Pages absolute, raw GitHub, jsDelivr CDN.
  - Minor UX: loaded badge, Select all/Clear buttons, inline favicon.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MUSPAD Dynamic Dashboard</title>

  <!-- Bootstrap CSS + Icons (no SRI to avoid integrity mismatches) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">

  <!-- Plotly.js for charts + PapaParse for CSV -->
  <script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Tiny inline favicon to avoid 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%23007bff'/%3E%3Ctext x='50%25' y='54%25' font-size='42' text-anchor='middle' fill='white'%3EM%3C/text%3E%3C/svg%3E"/>

  <style>
    :root {
      --sidebar-w: 50px;
      --card-min: 400px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Helvetica, sans-serif; overflow: hidden; }
    #app { display: flex; height: 100vh; overflow: hidden; }

    /* Sidebar */
    #sidebar {
      width: var(--sidebar-w);
      background: #f5f5f5;
      border-right: 1px solid #e1e1e1;
      display: flex; flex-direction: column; align-items: center; gap: .75rem;
      padding: .75rem .25rem;
    }
    #sidebar button {
      width: 36px; height: 36px; border: 0; background: transparent; border-radius: 8px;
      display: grid; place-items: center; font-size: 1.25rem; color: #333; cursor: pointer;
    }
    #sidebar button:hover { background: #e9ecef; color: #0d6efd; }

    /* Main column */
    #main { flex: 1; display: flex; flex-direction: column; min-width: 0; overflow: hidden; }

    /* Header */
    #header {
      display: flex; align-items: center; gap: 1rem;
      padding: .5rem 1rem; border-bottom: 1px solid #e1e1e1; background: #fff;
    }
    #title { margin: 0; font-size: 1.5rem; font-weight: 600; }
    #loadedBadge { font-size: .9rem; color: #6c757d; }
    .header-spacer { flex: 1; }
    .date-range { display: flex; gap: .5rem; }

    /* Panels */
    .panel { display: none; background: #f8f9fa; border-bottom: 1px solid #e1e1e1; padding: .75rem 1rem; overflow: auto; }
    .panel.active { display: block; }
    .panel h5 { margin-bottom: .75rem; }

    .filter-row { display: grid; grid-template-columns: 1fr auto auto; gap: .5rem; align-items: start; }
    .filter-actions .btn { white-space: nowrap; }

    /* Grid */
    #grid {
      flex: 1; overflow: auto; padding: 1rem;
      display: flex; flex-wrap: wrap; gap: 1rem;
    }
    .card-chart {
      width: calc(50% - .5rem);
      min-width: var(--card-min);
      background: #fff; border: 1px solid #e1e1e1; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,.06);
    }
    .card-chart .card-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: .5rem .75rem; border-bottom: 1px solid #eee;
    }
    .card-chart .card-header h6 { margin: 0; font-size: 1rem; font-weight: 600; }
    .card-chart .remove { border: 0; background: transparent; color: #6c757d; font-size: 1.1rem; }
    .card-chart .remove:hover { color: #dc3545; }
    .card-chart .plot { height: 320px; padding: .5rem; }

    @media (max-width: 800px) {
      .card-chart { width: 100%; min-width: 100%; }
    }

    /* Modal */
    #modal {
      position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.45); z-index: 1000;
      padding: 1rem;
    }
    #modal .sheet {
      width: min(600px, 100%); background: #fff; border-radius: 10px; padding: 1rem 1rem 1.25rem;
      box-shadow: 0 8px 24px rgba(0,0,0,.2);
    }
    #modal .grid { display: grid; gap: .75rem; }
    #modal .actions { display: flex; justify-content: flex-end; gap: .5rem; margin-top: .75rem; }
  </style>
</head>
<body>
  <div id="app">
    <!-- Sidebar -->
    <aside id="sidebar" aria-label="Toolbar">
      <button id="btnFilters" title="Filters" aria-label="Filters"><i class="bi bi-funnel-fill"></i></button>
      <button id="btnData" title="Data table" aria-label="Data"><i class="bi bi-table"></i></button>
      <button id="btnSettings" title="Settings" aria-label="Settings"><i class="bi bi-gear-fill"></i></button>
      <button id="btnAdd" title="Add chart" aria-label="Add chart"><i class="bi bi-plus-lg"></i></button>
    </aside>

    <!-- Main -->
    <main id="main">
      <header id="header">
        <h1 id="title">MUSPAD Dynamic Dashboard</h1>
        <span id="loadedBadge" aria-live="polite"></span>
        <div class="header-spacer"></div>
        <div class="date-range">
          <input type="date" id="startDate" aria-label="Start date">
          <input type="date" id="endDate" aria-label="End date">
        </div>
      </header>

      <!-- Filters -->
      <section id="panelFilters" class="panel" aria-label="Filters">
        <h5 class="mb-3">Filters</h5>

        <div class="mb-3">
          <label class="form-label">Age groups</label>
          <div class="filter-row">
            <select id="selAge" class="form-select" multiple size="6" aria-label="Age groups"></select>
            <div class="filter-actions">
              <button id="ageSelectAll" class="btn btn-outline-secondary btn-sm">Select all</button>
              <button id="ageClear" class="btn btn-outline-secondary btn-sm">Clear</button>
            </div>
          </div>
        </div>

        <div class="mb-2">
          <label class="form-label">Employment types</label>
          <div class="filter-row">
            <select id="selEmp" class="form-select" multiple size="6" aria-label="Employment types"></select>
            <div class="filter-actions">
              <button id="empSelectAll" class="btn btn-outline-secondary btn-sm">Select all</button>
              <button id="empClear" class="btn btn-outline-secondary btn-sm">Clear</button>
            </div>
          </div>
        </div>
      </section>

      <!-- Data table -->
      <section id="panelData" class="panel" aria-label="Data preview">
        <h5 class="mb-2">Data Preview</h5>
        <div class="table-responsive" id="tableWrap"></div>
      </section>

      <!-- Settings -->
      <section id="panelSettings" class="panel" aria-label="Settings">
        <h5>Settings</h5>
        <p class="text-muted mb-0">Add theme/layout options here as needed.</p>
      </section>

      <!-- Chart grid -->
      <section id="grid" aria-label="Charts"></section>
    </main>
  </div>

  <!-- Chart Builder Modal -->
  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="sheet">
      <h5 id="modalTitle" class="mb-3">Create chart</h5>
      <div class="grid">
        <div>
          <label class="form-label">Chart type</label>
          <select id="fldType" class="form-select">
            <option value="bar">Bar</option>
            <option value="pie">Pie</option>
            <option value="line">Line</option>
            <option value="scatter">Scatter</option>
          </select>
        </div>
        <div>
          <label class="form-label">X / Category</label>
          <select id="fldX" class="form-select"></select>
        </div>
        <div>
          <label class="form-label">Y (numeric)</label>
          <select id="fldY" class="form-select"></select>
        </div>
        <div>
          <label class="form-label">Color / Group (optional)</label>
          <select id="fldColor" class="form-select"></select>
        </div>
        <div>
          <label class="form-label">Aggregation</label>
          <select id="fldAgg" class="form-select">
            <option value="count">Count</option>
            <option value="sum">Sum</option>
            <option value="mean">Mean</option>
          </select>
        </div>
      </div>
      <div class="actions">
        <button id="btnCancel" class="btn btn-outline-secondary">Cancel</button>
        <button id="btnCreate" class="btn btn-primary">Create</button>
      </div>
    </div>
  </div>

  <script>
    // ----------------------------
    // Global state
    // ----------------------------
    let rawData = [];
    let filtered = [];
    let columns = [];
    let charts = [];
    let dateCol = null;
    let ageCol = null;
    let empCol = null;

    // ----------------------------
    // Boot
    // ----------------------------
    document.addEventListener('DOMContentLoaded', () => {
      wireUI();
      loadCSV();
    });

    function wireUI() {
      // Sidebar toggles
      id('btnFilters').addEventListener('click', () => toggle('panelFilters'));
      id('btnData').addEventListener('click', () => toggle('panelData'));
      id('btnSettings').addEventListener('click', () => toggle('panelSettings'));
      id('btnAdd').addEventListener('click', openModal);

      // Date change
      id('startDate').addEventListener('change', applyFilters);
      id('endDate').addEventListener('change', applyFilters);

      // Modal controls
      id('btnCancel').addEventListener('click', closeModal);
      id('btnCreate').addEventListener('click', () => {
        const cfg = {
          type: id('fldType').value,
          x: id('fldX').value,
          y: id('fldY').value,
          color: id('fldColor').value || null,
          agg: id('fldAgg').value
        };
        addChart(cfg);
        closeModal();
      });
      // close modal by clicking backdrop
      id('modal').addEventListener('click', (e) => {
        if (e.target === id('modal')) closeModal();
      });

      // Filter helper buttons
      id('ageSelectAll').addEventListener('click', () => selectAll(id('selAge')));
      id('ageClear').addEventListener('click', () => clearAll(id('selAge')));
      id('empSelectAll').addEventListener('click', () => selectAll(id('selEmp')));
      id('empClear').addEventListener('click', () => clearAll(id('selEmp')));
    }

    // ----------------------------
    // Data loading (with fallbacks)
    // ----------------------------
    function loadCSV() {
      const urls = [
        // 1) Relative to GitHub Pages root (docs/ is the site root)
        'data/df3_full_for_pivot.csv',
        // 2) Explicit Pages URL
        'https://sina-khajehzadeh.github.io/muspad-study-dashboard/data/df3_full_for_pivot.csv',
        // 3) Raw GitHub
        'https://raw.githubusercontent.com/Sina-Khajehzadeh/muspad-study-dashboard/main/docs/data/df3_full_for_pivot.csv',
        // 4) jsDelivr (may cache; keep as last resort)
        'https://cdn.jsdelivr.net/gh/Sina-Khajehzadeh/muspad-study-dashboard/docs/data/df3_full_for_pivot.csv'
      ];

      let idx = 0;
      const tryNext = () => {
        if (idx >= urls.length) {
          alert('Failed to load CSV from all sources.');
          return;
        }
        const url = urls[idx++];
        console.log('Loading data from', url);
        Papa.parse(url, {
          download: true,
          header: true,
          skipEmptyLines: true,
          dynamicTyping: true,
          worker: false,
          delimiter: "", // auto-detect
          transformHeader: (h) => (h || '').replace(/^\uFEFF/, '').trim(),
          complete: (res) => {
            if (!res || !Array.isArray(res.data) || res.data.length === 0) {
              console.warn('Parsed but empty. Trying next source…');
              tryNext();
              return;
            }
            rawData = res.data;
            columns = (res.meta && res.meta.fields && res.meta.fields.length)
              ? res.meta.fields
              : Object.keys(rawData[0] || {});
            id('loadedBadge').textContent = `Loaded ${rawData.length.toLocaleString()} rows • ${columns.length} columns`;

            detectColumns();
            populateFilters();
            populateBuilderSelects();
            // Start with data visible & some starter charts
            show('panelData', true);
            applyFilters();
            autoStarterCharts();
          },
          error: (err) => {
            console.error('Papa error:', err);
            tryNext();
          }
        });
      };
      tryNext();
    }

    // ----------------------------
    // Column detection (date/age/employment)
    // ----------------------------
    function detectColumns() {
      // 1) Date column: prefer names that hint date/time and pass parse checks
      const nameHint = /(date|time|_dt|_time|timestamp)/i;
      const candidates = columns.filter(c => nameHint.test(c));
      const ranked = (candidates.length ? candidates : columns).map(c => {
        const score = scoreDateColumn(c);
        return { col: c, ...score };
      }).filter(s => s.valid);

      ranked.sort((a,b) => b.confidence - a.confidence);
      dateCol = ranked.length ? ranked[0].col : null;

      // 2) Age group columns (list includes dataset-specific names)
      const ageCandidates = [
        'age_group','ageGroup','Age_Group',
        'age_group_22_1','age_group_22_2','age_group_23_1','age_group_23_2'
      ];
      ageCol = ageCandidates.find(c => columns.includes(c)) || null;

      // 3) Employment type columns (extended list, includes "langfragen" variant)
      const empCandidates = [
        'employment_type','employmentType','Employment_Type',
        'X20_21_kurzfragen_employment_type_clean','employment_type_clean',
        'X20_21_langfragen_employment_type_clean'
      ];
      empCol = empCandidates.find(c => columns.includes(c)) || null;
    }

    // Heuristic to validate date-like column
    function scoreDateColumn(col) {
      const vals = sampleValues(col, 300);
      let parsed = 0, withinRange = 0;
      for (const v of vals) {
        const d = new Date(v);
        if (!isNaN(d)) {
          parsed++;
          const y = d.getUTCFullYear();
          if (y >= 1990 && y <= 2100) withinRange++;
        }
      }
      const rate = vals.length ? parsed / vals.length : 0;
      const rangeRate = vals.length ? withinRange / vals.length : 0;
      const valid = rate >= 0.7 && rangeRate >= 0.7;
      const confidence = (rate + rangeRate) / 2 + (/(date|time|timestamp)/i.test(col) ? 0.1 : 0);
      return { valid, confidence };
    }

    function sampleValues(col, n=200) {
      const arr = [];
      const step = Math.max(1, Math.floor(rawData.length / n));
      for (let i=0; i<rawData.length; i+=step) {
        const v = rawData[i]?.[col];
        if (v !== undefined && v !== null && v !== '') arr.push(v);
        if (arr.length >= n) break;
      }
      return arr;
    }

    // ----------------------------
    // Populate filters & builder
    // ----------------------------
    function populateFilters() {
      const $age = id('selAge');
      const $emp = id('selEmp');

      // Fill age groups
      if (ageCol) {
        fillMultiSelect($age, uniqueNonEmpty(rawData.map(r => r[ageCol])));
        $age.dataset.col = ageCol;
      }

      // Fill employment types
      if (empCol) {
        fillMultiSelect($emp, uniqueNonEmpty(rawData.map(r => r[empCol])));
        $emp.dataset.col = empCol;
      }

      // Prepare date inputs (leave blank to avoid default filtering)
      if (dateCol) {
        const dates = rawData
          .map(r => new Date(r[dateCol]))
          .filter(d => !isNaN(d))
          .sort((a,b) => a-b);
        if (dates.length) {
          const minISO = toISO(dates[0]);
          const maxISO = toISO(dates[dates.length-1]);
          id('startDate').min = minISO; id('startDate').max = maxISO;
          id('endDate').min = minISO;   id('endDate').max = maxISO;
          id('startDate').dataset.col = dateCol;
          id('endDate').dataset.col = dateCol;
        }
      }

      // Trigger filtering on select changes
      $age.addEventListener('change', applyFilters);
      $emp.addEventListener('change', applyFilters);
    }

    function populateBuilderSelects() {
      const xSel = id('fldX'), ySel = id('fldY'), cSel = id('fldColor');
      xSel.innerHTML = ySel.innerHTML = cSel.innerHTML = '';
      for (const c of columns) {
        appendOption(xSel, c); appendOption(ySel, c); appendOption(cSel, c);
      }
    }

    // ----------------------------
    // Filtering + table
    // ----------------------------
    function applyFilters() {
      const s = id('startDate').value ? new Date(id('startDate').value) : null;
      const e = id('endDate').value ? new Date(id('endDate').value) : null;
      const ageSel = id('selAge');  const empSel = id('selEmp');

      const chosenAge = (ageSel.options.length && ageSel.dataset.col)
        ? Array.from(ageSel.selectedOptions).map(o => String(o.value)) : null;
      const chosenEmp = (empSel.options.length && empSel.dataset.col)
        ? Array.from(empSel.selectedOptions).map(o => String(o.value)) : null;

      filtered = rawData.filter(r => {
        // date
        if (dateCol && (s || e)) {
          const d = new Date(r[dateCol]);
          if (isNaN(d)) return false;
          if (s && d < s) return false;
          if (e && d > e) return false;
        }
        // age
        if (chosenAge && chosenAge.length) {
          if (!chosenAge.includes(String(r[ageCol]))) return false;
        }
        // employment
        if (chosenEmp && chosenEmp.length) {
          if (!chosenEmp.includes(String(r[empCol]))) return false;
        }
        return true;
      });

      updateTable();
      charts.forEach(drawChart);
    }

    function updateTable() {
      const wrap = id('tableWrap');
      wrap.innerHTML = '';
      if (!filtered.length) {
        wrap.innerHTML = '<div class="text-muted">No data to display</div>';
        return;
      }
      const table = document.createElement('table');
      table.className = 'table table-sm table-striped';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      for (const c of columns) {
        const th = document.createElement('th'); th.textContent = c; trh.appendChild(th);
      }
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      const rows = filtered.slice(0, 100);
      for (const r of rows) {
        const tr = document.createElement('tr');
        for (const c of columns) {
          const td = document.createElement('td');
          const v = r[c]; td.textContent = (v === undefined || v === null) ? '' : v;
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(thead); table.appendChild(tbody);
      wrap.appendChild(table);
    }

    // ----------------------------
    // Starter charts (auto-create)
    // ----------------------------
    function autoStarterCharts() {
      // derive candidates
      const numericCols = columns.filter(c => looksNumericColumn(c));
      const catCols = columns.filter(c => looksCategoricalColumn(c));

      // prefer knowns
      const income = ['X20_21_langfragen_income', 'income'].find(c => columns.includes(c)) || numericCols[0];
      const age = ageCol || catCols.find(c => /age/i.test(c)) || catCols[0];
      const emp = empCol || catCols.find(c => /employ|job|work/i.test(c));

      // 1) Pie of employment counts (if available)
      if (emp) addChart({ type: 'pie', x: emp, y: income || emp, agg: 'count' });

      // 2) Bar: mean income by age group (or first numeric)
      if (age && income) addChart({ type: 'bar', x: age, y: income, agg: 'mean' });

      // 3) Line over time (if we have a date + numeric)
      if (dateCol && income) addChart({ type: 'line', x: dateCol, y: income, agg: 'mean' });
    }

    function looksNumericColumn(col) {
      const vals = sampleValues(col, 200);
      if (!vals.length) return false;
      let nums = 0;
      for (const v of vals) if (typeof v === 'number' && !Number.isNaN(v)) nums++;
      // Consider numeric if at least 70% are numbers
      return nums / vals.length >= 0.7;
    }

    function looksCategoricalColumn(col) {
      const vals = sampleValues(col, 400);
      const uniq = new Set(vals.filter(v => v !== '' && v !== null && v !== undefined).map(String));
      // categorical if distinct values between 2 and 20 and not mostly numbers
      const mostlyNums = looksNumericColumn(col);
      return !mostlyNums && uniq.size >= 2 && uniq.size <= 20;
    }

    // ----------------------------
    // Charting
    // ----------------------------
    function addChart(cfg) {
      charts.push(cfg);
      const card = document.createElement('div');
      card.className = 'card-chart';
      card.innerHTML = `
        <div class="card-header">
          <h6>${titleFor(cfg)}</h6>
          <button class="remove" title="Remove"><i class="bi bi-x-lg"></i></button>
        </div>
        <div class="plot"></div>
      `;
      id('grid').appendChild(card);
      cfg._el = card.querySelector('.plot');
      card.querySelector('.remove').addEventListener('click', () => {
        charts = charts.filter(c => c !== cfg);
        card.remove();
      });
      drawChart(cfg);
    }

    function titleFor(cfg) {
      const t = cfg.type[0].toUpperCase() + cfg.type.slice(1);
      const parts = [`${t}`];
      if (cfg.x) parts.push(`X: ${cfg.x}`);
      if (cfg.y && cfg.agg) parts.push(`Y: ${cfg.agg}(${cfg.y})`);
      if (cfg.color) parts.push(`Color: ${cfg.color}`);
      return parts.join(' · ');
    }

    function drawChart(cfg) {
      const el = cfg._el;
      if (!filtered.length) { el.innerHTML = '<div class="text-muted p-2">No data</div>'; return; }

      // Grouping helper
      const groupBy = (rows, keys) => {
        const map = new Map();
        for (const r of rows) {
          const key = keys.map(k => String(r[k])).join('¦'); // join to single key
          if (!map.has(key)) map.set(key, []);
          map.get(key).push(r);
        }
        return { map, keys };
      };

      // Aggregator on Y
      const agg = (rows) => {
        if (cfg.agg === 'count') return rows.length;
        const vals = rows.map(r => +r[cfg.y]).filter(v => !Number.isNaN(v));
        if (!vals.length) return 0;
        if (cfg.agg === 'sum') return vals.reduce((a,b)=>a+b,0);
        if (cfg.agg === 'mean') return vals.reduce((a,b)=>a+b,0) / vals.length;
        return rows.length;
      };

      let fig = { data: [], layout: { margin: {l:50,r:20,b:50,t:40}, title: titleFor(cfg) } };

      if (cfg.type === 'bar' || cfg.type === 'pie') {
        // group by X and optionally Color
        const by = cfg.color ? [cfg.x, cfg.color] : [cfg.x];
        const g = groupBy(filtered, by);

        // collect unique X and Color keys
        const xs = new Set(); const colors = new Set();
        for (const key of g.map.keys()) {
          const parts = key.split('¦');
          xs.add(parts[0]);
          if (cfg.color) colors.add(parts[1]);
        }
        const xArr = Array.from(xs);
        const colorArr = cfg.color ? Array.from(colors) : [null];

        if (cfg.type === 'bar') {
          for (const cval of colorArr) {
            const y = xArr.map(xval => {
              const key = cfg.color ? [xval, cval].join('¦') : String(xval);
              const rows = g.map.get(key) || [];
              return agg(rows);
            });
            fig.data.push({ x: xArr, y, type: 'bar', name: cval ?? 'value' });
          }
          fig.layout.barmode = 'group';
          fig.layout.xaxis = { title: cfg.x };
          if (cfg.y) fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };
        } else {
          // pie ignores Color; just totals per X
          const values = xArr.map(xval => {
            const rows = Array.from(g.map.entries())
              .filter(([k]) => k.split('¦')[0] == xval)
              .flatMap(([,rows]) => rows);
            return agg(rows);
          });
          fig.data.push({ labels: xArr, values, type: 'pie', hole: .35 });
        }

      } else if (cfg.type === 'line') {
        // group by X value (date or numeric) and aggregate Y per X
        const g = groupBy(filtered, [cfg.x]);
        const xVals = Array.from(g.map.keys()).map(k => k.split('¦')[0]);
        // sort: dates > numeric > string
        const sorted = xVals.slice().sort((a,b) => {
          const da = new Date(a), db = new Date(b);
          if (!isNaN(da) && !isNaN(db)) return da - db;
          const na = +a, nb = +b;
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
          return String(a).localeCompare(String(b));
        });
        const yVals = sorted.map(xv => {
          const rows = g.map.get(String(xv)) || g.map.get(xv) || [];
          return agg(rows);
        });
        fig.data.push({ x: sorted, y: yVals, type: 'scatter', mode: 'lines+markers' });
        fig.layout.xaxis = { title: cfg.x };
        if (cfg.y) fig.layout.yaxis = { title: `${cfg.agg}(${cfg.y})` };

      } else if (cfg.type === 'scatter') {
        const x = filtered.map(r => r[cfg.x]);
        const y = filtered.map(r => r[cfg.y]);

        if (cfg.color) {
          // If color is numeric -> single trace with continuous colorscale
          if (looksNumericColumn(cfg.color)) {
            fig.data.push({
              x, y, mode: 'markers', type: 'scatter',
              marker: { color: filtered.map(r => r[cfg.color]), showscale: true }
            });
          } else {
            // Categorical colors -> multiple traces
            const cats = uniqueNonEmpty(filtered.map(r => r[cfg.color])).slice(0, 15);
            for (const c of cats) {
              const pts = filtered.filter(r => String(r[cfg.color]) === String(c));
              fig.data.push({
                x: pts.map(r => r[cfg.x]),
                y: pts.map(r => r[cfg.y]),
                mode: 'markers', type: 'scatter', name: c
              });
            }
          }
        } else {
          fig.data.push({ x, y, mode: 'markers', type: 'scatter' });
        }
        fig.layout.xaxis = { title: cfg.x };
        fig.layout.yaxis = { title: cfg.y };
      }

      Plotly.newPlot(el, fig.data, fig.layout, { responsive: true });
    }

    // ----------------------------
    // Utilities
    // ----------------------------
    const id = (s) => document.getElementById(s);
    const toISO = (d) => new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().split('T')[0];
    const uniqueNonEmpty = (arr) => Array.from(new Set(arr.map(v => v===null||v===undefined?'' : String(v)).filter(s => s !== ''))).sort();

    function appendOption(sel, value, label) {
      const o = document.createElement('option');
      o.value = value; o.textContent = label ?? value;
      sel.appendChild(o);
    }
    function fillMultiSelect(sel, values) {
      sel.innerHTML = '';
      for (const v of values) {
        const o = document.createElement('option');
        o.value = v; o.textContent = v; o.selected = true;
        sel.appendChild(o);
      }
    }
    function selectAll(sel){ for (const o of sel.options) o.selected = true; sel.dispatchEvent(new Event('change')); }
    function clearAll(sel){ for (const o of sel.options) o.selected = false; sel.dispatchEvent(new Event('change')); }

    function toggle(panelId) {
      const el = id(panelId);
      el.classList.toggle('active');
    }
    function show(panelId, on=true) {
      const el = id(panelId);
      if (on) el.classList.add('active'); else el.classList.remove('active');
    }
    function openModal(){ id('modal').style.display = 'grid'; }
    function closeModal(){ id('modal').style.display = 'none'; }
  </script>
</body>
</html>
